{"version":3,"file":"index.es.js","sources":["../src/toolkit/input-rules/custom-input-rules.ts","../src/toolkit/input-rules/mark-rule.ts","../src/toolkit/position/index.ts","../src/toolkit/prose/helper.ts","../src/toolkit/prose/node.ts","../src/toolkit/prose/schema.ts","../src/toolkit/prose/selection.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { InputRule } from 'prosemirror-inputrules';\nimport { EditorState, Plugin, PluginKey, PluginSpec, TextSelection, Transaction } from 'prosemirror-state';\nimport type { EditorView } from 'prosemirror-view';\n\nfunction run(view: EditorView, from: number, to: number, text: string, rules: InputRule[], plugin: Plugin) {\n    if (view.composing) return false;\n    const state = view.state,\n        $from = state.doc.resolve(from);\n    if ($from.parent.type.spec.code) return false;\n    const textBefore =\n        $from.parent.textBetween(Math.max(0, $from.parentOffset - 500), $from.parentOffset, undefined, '\\ufffc') + text;\n    for (let i = 0; i < rules.length; i++) {\n        const match = (rules[i] as { match: RegExp }).match.exec(textBefore);\n        const tr =\n            match &&\n            match[0] &&\n            (\n                rules[i] as { handler: (state: EditorState, match: string[], from: number, to: number) => Transaction }\n            ).handler(state, match, from - (match[0].length - text.length), to);\n        if (!tr) continue;\n        view.dispatch(tr.setMeta(plugin, { transform: tr, from, to, text }));\n        return true;\n    }\n    return false;\n}\n\nexport const customInputRulesKey = new PluginKey('MILKDOWN_PLUGIN_CUSTOM_INPUTRULES');\nexport const customInputRules = ({ rules }: { rules: InputRule[] }): Plugin => {\n    const plugin: Plugin = new Plugin({\n        key: customInputRulesKey,\n        isInputRules: true,\n\n        state: {\n            init() {\n                return null;\n            },\n            apply(tr, prev) {\n                const stored = tr.getMeta(this);\n                if (stored) return stored;\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            },\n        },\n        props: {\n            handleTextInput(view, from, to, text) {\n                return run(view, from, to, text, rules, plugin);\n            },\n            handleDOMEvents: {\n                compositionend: (view) => {\n                    setTimeout(() => {\n                        const { $cursor } = view.state.selection as TextSelection;\n                        if ($cursor) run(view, $cursor.pos, $cursor.pos, '', rules, plugin);\n                    });\n                    return false;\n                },\n            },\n            handleKeyDown(view, event) {\n                if (event.key !== 'Enter') return false;\n                const { $cursor } = view.state.selection as TextSelection;\n                if ($cursor) return run(view, $cursor.pos, $cursor.pos, '\\n', rules, plugin);\n                return false;\n            },\n        },\n    } as PluginSpec);\n    return plugin;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { InputRule } from 'prosemirror-inputrules';\nimport { Mark, MarkType } from 'prosemirror-model';\nimport { EditorState } from 'prosemirror-state';\n\nexport function markRule(regexp: RegExp, markType: MarkType): InputRule {\n    return new InputRule(regexp, (state, match, start, end) => {\n        const { tr } = state;\n        const matchLength = match.length;\n\n        let markStart = start;\n        let markEnd = end;\n\n        if (match[matchLength - 1]) {\n            const first = match[0] as string;\n            const last = match[matchLength - 1] as string;\n            const last1 = match[matchLength - 2] as string;\n\n            const matchStart = start + first.indexOf(last1);\n            const matchEnd = matchStart + last1.length - 1;\n            const textStart = matchStart + last1.lastIndexOf(last);\n            const textEnd = textStart + last.length;\n\n            const excludedMarks = getMarksBetween(start, end, state)\n                .filter((item) => item.mark.type.excludes(markType))\n                .filter((item) => item.end > matchStart);\n\n            if (excludedMarks.length) {\n                return null;\n            }\n\n            if (textEnd < matchEnd) {\n                tr.delete(textEnd, matchEnd);\n            }\n            if (textStart > matchStart) {\n                tr.delete(matchStart, textStart);\n            }\n            markStart = matchStart;\n            markEnd = markStart + last.length;\n        }\n        tr.addMark(markStart, markEnd, markType.create());\n        tr.removeStoredMark(markType);\n        return tr;\n    });\n}\n\nfunction getMarksBetween(start: number, end: number, state: EditorState) {\n    let marks: { start: number; end: number; mark: Mark }[] = [];\n\n    state.doc.nodesBetween(start, end, (node, pos) => {\n        marks = [\n            ...marks,\n            ...node.marks.map((mark) => ({\n                start: pos,\n                end: pos + node.nodeSize,\n                mark,\n            })),\n        ];\n    });\n\n    return marks;\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { EditorView } from 'prosemirror-view';\n\ntype Point = [top: number, left: number];\n\nexport const calculateNodePosition = (\n    view: EditorView,\n    target: HTMLElement,\n    handler: (selectedRect: DOMRect, targetRect: DOMRect, parentRect: DOMRect) => Point,\n) => {\n    const state = view.state;\n    const { from } = state.selection;\n\n    const { node } = view.domAtPos(from);\n    const element = node instanceof Text ? node.parentElement : node;\n    if (!(element instanceof HTMLElement)) {\n        throw new Error();\n    }\n\n    const selectedNodeRect = element.getBoundingClientRect();\n    const targetNodeRect = target.getBoundingClientRect();\n    const parentNodeRect = target.parentElement?.getBoundingClientRect();\n    if (!parentNodeRect) {\n        throw new Error();\n    }\n\n    const [top, left] = handler(selectedNodeRect, targetNodeRect, parentNodeRect);\n\n    target.style.top = top + 'px';\n    target.style.left = left + 'px';\n};\n\ntype Rect = {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n};\n\nexport const calculateTextPosition = (\n    view: EditorView,\n    target: HTMLElement,\n    handler: (start: Rect, end: Rect, targetRect: DOMRect, parentRect: DOMRect) => Point,\n) => {\n    const state = view.state;\n    const { from, to } = state.selection;\n    const start = view.coordsAtPos(from);\n    const end = view.coordsAtPos(to);\n\n    const targetNodeRect = target.getBoundingClientRect();\n    const parent = target.parentElement;\n    if (!parent) {\n        throw new Error();\n    }\n    const parentNodeRect = parent.getBoundingClientRect();\n\n    const [top, left] = handler(start, end, targetNodeRect, parentNodeRect);\n\n    target.style.top = top + 'px';\n    target.style.left = left + 'px';\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Node as ProseNode, NodeType } from 'prosemirror-model';\nimport type { Transaction } from 'prosemirror-state';\n\nexport const cloneTr = (tr: Transaction) => {\n    return Object.assign(Object.create(tr), tr).setTime(Date.now());\n};\n\nexport const equalNodeType = (nodeType: NodeType | NodeType[], node: ProseNode) => {\n    return (Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1) || node.type === nodeType;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MarkType, Node as ProseNode } from 'prosemirror-model';\n\nimport type { Predicate } from './types';\n\nexport type NodeWithPos = { pos: number; node: ProseNode };\n\nexport const flatten = (node: ProseNode, descend = true): NodeWithPos[] => {\n    const result: NodeWithPos[] = [];\n    node.descendants((child, pos) => {\n        result.push({ node: child, pos });\n        if (!descend) {\n            return false;\n        }\n        return undefined;\n    });\n    return result;\n};\n\nexport const findChildren =\n    (predicate: Predicate) =>\n    (node: ProseNode, descend?: boolean): NodeWithPos[] =>\n        flatten(node, descend).filter((child) => predicate(child.node));\n\nexport const findChildrenByMark = (node: ProseNode, markType: MarkType, descend?: boolean): NodeWithPos[] =>\n    findChildren((child) => Boolean(markType.isInSet(child.marks)))(node, descend);\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { getAtomFromSchemaFail } from '@milkdown/exception';\nimport type { MarkType, NodeType, Schema } from 'prosemirror-model';\n\nexport const getNodeFromSchema = (type: string, schema: Schema): NodeType => {\n    const target = schema.nodes[type];\n\n    if (!target) {\n        throw getAtomFromSchemaFail('node', type);\n    }\n\n    return target;\n};\n\nexport const getMarkFromSchema = (type: string, schema: Schema): MarkType => {\n    const target = schema.marks[type];\n\n    if (!target) {\n        throw getAtomFromSchemaFail('mark', type);\n    }\n\n    return target;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Node as ProseNode, NodeType, ResolvedPos } from 'prosemirror-model';\nimport { NodeSelection, Selection } from 'prosemirror-state';\n\nimport { equalNodeType } from './helper';\nimport type { Predicate } from './types';\n\nexport type ContentNodeWithPos = { pos: number; start: number; depth: number; node: ProseNode };\n\nexport const findParentNodeClosestToPos =\n    (predicate: Predicate) =>\n    ($pos: ResolvedPos): ContentNodeWithPos | undefined => {\n        for (let i = $pos.depth; i > 0; i--) {\n            const node = $pos.node(i);\n            if (predicate(node)) {\n                return {\n                    pos: i > 0 ? $pos.before(i) : 0,\n                    start: $pos.start(i),\n                    depth: i,\n                    node,\n                };\n            }\n        }\n        return;\n    };\n\nexport const findParentNode =\n    (predicate: Predicate) =>\n    (selection: Selection): ContentNodeWithPos | undefined => {\n        return findParentNodeClosestToPos(predicate)(selection.$from);\n    };\n\nexport const findSelectedNodeOfType = (selection: Selection, nodeType: NodeType): ContentNodeWithPos | undefined => {\n    if (!(selection instanceof NodeSelection)) {\n        return;\n    }\n    const { node, $from } = selection;\n    if (equalNodeType(nodeType, node)) {\n        return { node, pos: $from.pos, start: $from.start($from.depth), depth: $from.depth };\n    }\n    return undefined;\n};\n"],"names":[],"mappings":"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"}