var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { SupportedKeys as SupportedKeys$2, commonmark, commands as commands$1 } from "@milkdown/preset-commonmark";
export { InsertHardbreak, InsertHr, InsertImage, LiftListItem, ModifyImage, ModifyLink, SinkListItem, SplitListItem, ToggleBold, ToggleInlineCode, ToggleItalic, ToggleLink, TurnIntoCodeFence, TurnIntoHeading, TurnIntoText, WrapInBlockquote, WrapInBulletList, WrapInOrderedList, blockquote, bulletList, codeFence, codeInline, commonmark, commonmarkNodes, commonmarkPlugins, doc, em, hardbreak, heading, hr, image, link, listItem, orderedList, paragraph, strong, text } from "@milkdown/preset-commonmark";
import { $prose, createPlugin, createShortcut, createMark, createNode, AtomList, $remark } from "@milkdown/utils";
import remarkGFM from "remark-gfm";
import { inputRules, InputRule, isInTable, Selection, findParentNode, TableMap, tableNodeTypes, CellSelection, cloneTr, addColumnBefore, addColumnAfter, selectedRect, setCellAttr, deleteTable, deleteColumn, deleteRow, calculateNodePosition, Decoration, Plugin, PluginKey, DecorationSet, tableNodes, TextSelection, goToNextCell, columnResizing, tableEditing, markRule, toggleMark, wrappingInputRule, splitListItem, sinkListItem, liftListItem, wrapIn } from "@milkdown/prose";
import { themeToolCtx, createCmdKey, schemaCtx, createCmd } from "@milkdown/core";
const urlRegex = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)$/;
const proseUrlPlugin = () => inputRules({
  rules: [
    new InputRule(urlRegex, (state, match, start, end) => {
      const { schema: schema2 } = state;
      const [text2] = match;
      if (!text2)
        return null;
      return state.tr.replaceWith(start, end, schema2.text(text2)).addMark(start, text2.length + start, schema2.marks.link.create({ href: text2 }));
    })
  ]
});
const urlPlugin = $prose(() => proseUrlPlugin());
const exitTable = (node) => (state, dispatch) => {
  if (!isInTable(state)) {
    return false;
  }
  const { $head } = state.selection;
  const pos = $head.after();
  const tr = state.tr.replaceWith(pos, pos, node.createAndFill());
  tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
  dispatch == null ? void 0 : dispatch(tr.scrollIntoView());
  return true;
};
const findTable = (selection) => findParentNode((node) => node.type.spec["tableRole"] === "table")(selection);
const getCellsInColumn = (columnIndex) => (selection) => {
  const table2 = findTable(selection);
  if (!table2)
    return void 0;
  const map = TableMap.get(table2.node);
  if (columnIndex < 0 || columnIndex >= map.width) {
    return void 0;
  }
  return map.cellsInRect({ left: columnIndex, right: columnIndex + 1, top: 0, bottom: map.height }).map((pos) => {
    const node = table2.node.nodeAt(pos);
    if (!node)
      throw new Error();
    const start = pos + table2.start;
    return {
      pos: start,
      start: start + 1,
      node
    };
  });
};
const getCellsInRow = (rowIndex) => (selection) => {
  const table2 = findTable(selection);
  if (!table2)
    return void 0;
  const map = TableMap.get(table2.node);
  if (rowIndex < 0 || rowIndex >= map.height) {
    return void 0;
  }
  return map.cellsInRect({ left: 0, right: map.width, top: rowIndex, bottom: rowIndex + 1 }).map((pos) => {
    const node = table2.node.nodeAt(pos);
    if (!node)
      throw new Error();
    const start = pos + table2.start;
    return {
      pos: start,
      start: start + 1,
      node
    };
  });
};
const createTable = (schema2, rowsCount = 3, colsCount = 3) => {
  const { cell: tableCell, header_cell: tableHeader, row: tableRow, table: table2 } = tableNodeTypes(schema2);
  const cells = Array(colsCount).fill(0).map(() => tableCell.createAndFill(null));
  const headerCells = Array(colsCount).fill(0).map(() => tableHeader.createAndFill(null));
  const rows = Array(rowsCount).fill(0).map((_, i) => tableRow.create(null, i === 0 ? headerCells : cells));
  return table2.create(null, rows);
};
const selectLine = (type) => (index) => (tr) => {
  const table2 = findTable(tr.selection);
  const isRowSelection = type === "row";
  if (table2) {
    const map = TableMap.get(table2.node);
    if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {
      const lastCell = map.positionAt(isRowSelection ? index : map.height - 1, isRowSelection ? map.width - 1 : index, table2.node);
      const $lastCell = tr.doc.resolve(table2.start + lastCell);
      const createCellSelection = isRowSelection ? CellSelection.rowSelection : CellSelection.colSelection;
      const firstCell = map.positionAt(isRowSelection ? index : 0, isRowSelection ? 0 : index, table2.node);
      const $firstCell = tr.doc.resolve(table2.start + firstCell);
      return cloneTr(tr.setSelection(createCellSelection($lastCell, $firstCell)));
    }
  }
  return tr;
};
const getCellsInTable = (selection) => {
  const table2 = findTable(selection);
  if (!table2) {
    return;
  }
  const map = TableMap.get(table2.node);
  const cells = map.cellsInRect({
    left: 0,
    right: map.width,
    top: 0,
    bottom: map.height
  });
  return cells.map((nodePos) => {
    const node = table2.node.nodeAt(nodePos);
    const pos = nodePos + table2.start;
    return { pos, start: pos + 1, node };
  });
};
const selectTable = (tr) => {
  const cells = getCellsInTable(tr.selection);
  if (cells && cells[0]) {
    const $firstCell = tr.doc.resolve(cells[0].pos);
    const last = cells[cells.length - 1];
    if (last) {
      const $lastCell = tr.doc.resolve(last.pos);
      return cloneTr(tr.setSelection(new CellSelection($lastCell, $firstCell)));
    }
  }
  return tr;
};
function addRowWithAlignment(tr, { map, tableStart, table: table2 }, row) {
  const rowPos = Array(row).fill(0).reduce((acc, _, i) => {
    return acc + table2.child(i).nodeSize;
  }, tableStart);
  const { cell: cellType, row: rowType } = tableNodeTypes(table2.type.schema);
  const cells = Array(map.width).fill(0).map((_, col) => {
    const headerCol = table2.nodeAt(map.map[col]);
    return cellType.createAndFill({ alignment: headerCol == null ? void 0 : headerCol.attrs["alignment"] });
  });
  tr.insert(rowPos, rowType.create(null, cells));
  return tr;
}
const getCellSelection = (view) => view.state.selection;
const isFirstRowSelected = (selection) => {
  const map = TableMap.get(selection.$anchorCell.node(-1));
  const start = selection.$anchorCell.start(-1);
  const cells = map.cellsInRect({
    left: 0,
    right: map.width,
    top: 0,
    bottom: 1
  });
  const selectedCells = map.cellsInRect(map.rectBetween(selection.$anchorCell.pos - start, selection.$headCell.pos - start));
  for (let i = 0, count = cells.length; i < count; i++) {
    if (selectedCells.indexOf(cells[i]) === -1) {
      return false;
    }
  }
  return true;
};
const calculateItem = (actions, view) => {
  Object.values(actions).forEach((item) => {
    var _a;
    const disable = (_a = item.disable) == null ? void 0 : _a.call(item, view);
    if (disable) {
      item.$.classList.add("hide");
      return;
    }
    item.$.classList.remove("hide");
  });
};
var Action;
(function(Action2) {
  Action2[Action2["AddColLeft"] = 0] = "AddColLeft";
  Action2[Action2["AddColRight"] = 1] = "AddColRight";
  Action2[Action2["AddRowTop"] = 2] = "AddRowTop";
  Action2[Action2["AddRowBottom"] = 3] = "AddRowBottom";
  Action2[Action2["AlignLeft"] = 4] = "AlignLeft";
  Action2[Action2["AlignCenter"] = 5] = "AlignCenter";
  Action2[Action2["AlignRight"] = 6] = "AlignRight";
  Action2[Action2["Delete"] = 7] = "Delete";
})(Action || (Action = {}));
const createActions = (ctx) => ({
  [0]: {
    $: ctx.get(themeToolCtx).slots.icon("leftArrow"),
    command: () => addColumnBefore,
    disable: (view) => !getCellSelection(view).isColSelection()
  },
  [1]: {
    $: ctx.get(themeToolCtx).slots.icon("rightArrow"),
    command: () => addColumnAfter,
    disable: (view) => !getCellSelection(view).isColSelection()
  },
  [2]: {
    $: ctx.get(themeToolCtx).slots.icon("upArrow"),
    command: () => (state, dispatch) => {
      if (!isInTable(state))
        return false;
      if (dispatch) {
        const rect = selectedRect(state);
        dispatch(addRowWithAlignment(state.tr, rect, rect.top));
      }
      return true;
    },
    disable: (view) => !getCellSelection(view).isRowSelection() || getCellSelection(view).$head.parent.type.name === "table_header"
  },
  [3]: {
    $: ctx.get(themeToolCtx).slots.icon("downArrow"),
    command: () => (state, dispatch) => {
      if (!isInTable(state))
        return false;
      if (dispatch) {
        const rect = selectedRect(state);
        dispatch(addRowWithAlignment(state.tr, rect, rect.bottom));
      }
      return true;
    },
    disable: (view) => !getCellSelection(view).isRowSelection()
  },
  [4]: {
    $: ctx.get(themeToolCtx).slots.icon("alignLeft"),
    command: () => setCellAttr("alignment", "left"),
    disable: (view) => !getCellSelection(view).isColSelection()
  },
  [5]: {
    $: ctx.get(themeToolCtx).slots.icon("alignCenter"),
    command: () => setCellAttr("alignment", "center"),
    disable: (view) => !getCellSelection(view).isColSelection()
  },
  [6]: {
    $: ctx.get(themeToolCtx).slots.icon("alignRight"),
    command: () => setCellAttr("alignment", "right"),
    disable: (view) => !getCellSelection(view).isColSelection()
  },
  [7]: {
    $: ctx.get(themeToolCtx).slots.icon("delete"),
    command: (_, view) => {
      const selection = getCellSelection(view);
      const isCol = selection.isColSelection();
      const isRow = selection.isRowSelection();
      if (isCol && isRow) {
        return deleteTable;
      }
      if (isCol) {
        return deleteColumn;
      }
      return deleteRow;
    },
    disable: (view) => {
      const selection = getCellSelection(view);
      if (selection.isRowSelection()) {
        if (selection.isColSelection()) {
          return false;
        }
        return isFirstRowSelected(selection);
      }
      return false;
    }
  }
});
const calculatePosition = (view, dom) => {
  const { selection } = view.state;
  const isCol = selection.isColSelection();
  const isRow = selection.isRowSelection();
  calculateNodePosition(view, dom, (selected, target, parent) => {
    const $editor = dom.parentElement;
    if (!$editor) {
      throw new Error();
    }
    let left = !isRow ? selected.left - parent.left + (selected.width - target.width) / 2 : selected.left - parent.left - target.width / 2 - 8;
    const top = selected.top - parent.top - target.height - (isCol ? 14 : 0) - 14 + $editor.scrollTop;
    if (left < 0) {
      left = 0;
    }
    return [top, left];
  });
};
var ToolTipPos;
(function(ToolTipPos2) {
  ToolTipPos2["Left"] = "Left";
  ToolTipPos2["Top"] = "Top";
  ToolTipPos2["Point"] = "Point";
})(ToolTipPos || (ToolTipPos = {}));
const injectStyle$1 = ({ size, mixin, palette }, { css }) => {
  var _a, _b;
  return css`
    display: inline-flex;
    cursor: pointer;
    z-index: 2;

    justify-content: space-evenly;

    position: absolute;

    border-radius: ${size.radius};

    ${(_a = mixin.border) == null ? void 0 : _a.call(mixin)};

    ${(_b = mixin.shadow) == null ? void 0 : _b.call(mixin)};

    overflow: hidden;
    background: ${palette("surface")};

    .icon {
        position: relative;
        color: ${palette("solid", 0.87)};

        width: 3rem;
        line-height: 3rem;
        text-align: center;
        transition: all 0.4s ease-in-out;
        &:hover {
            background-color: ${palette("secondary", 0.12)};
        }
        &.active {
            color: ${palette("primary")};
        }
        &:not(:last-child)::after {
            content: '';
            position: absolute;
            right: 0px;
            top: 0;
            width: ${size.lineWidth};
            bottom: 0;
            background: ${palette("line")};
        }
    }
    &.hide,
    .hide {
        display: none;
    }
`;
};
const calculateClassName = (pos) => {
  switch (pos) {
    case ToolTipPos.Left: {
      return "milkdown-cell-left";
    }
    case ToolTipPos.Top: {
      return "milkdown-cell-top";
    }
    case ToolTipPos.Point:
    default: {
      return "milkdown-cell-point";
    }
  }
};
function createWidget(ctx, cell, pos, index = 0) {
  const widget = Decoration.widget(cell.pos + 1, (view) => {
    const div = document.createElement("div");
    div.classList.add(calculateClassName(pos));
    if (pos === ToolTipPos.Point) {
      div.appendChild(ctx.get(themeToolCtx).slots.icon("select"));
    }
    div.addEventListener("mousedown", (e) => {
      if (!view)
        return;
      e.preventDefault();
      switch (pos) {
        case ToolTipPos.Point: {
          view.dispatch(selectTable(view.state.tr));
          return;
        }
        case ToolTipPos.Left: {
          view.dispatch(selectLine("row")(index)(view.state.tr));
          return;
        }
        case ToolTipPos.Top: {
          view.dispatch(selectLine("col")(index)(view.state.tr));
          return;
        }
      }
    });
    return div;
  });
  return widget;
}
const operatorPlugin = (ctx, utils) => {
  const items = createActions(ctx);
  const tooltip = document.createElement("div");
  const style = utils.getStyle(injectStyle$1);
  if (style) {
    tooltip.classList.add(style);
  }
  tooltip.classList.add("table-tooltip", "hide");
  return new Plugin({
    key: new PluginKey("MILKDOWN_TABLE_OP"),
    props: {
      decorations: (state) => {
        const decorations = [];
        const leftCells = getCellsInColumn(0)(state.selection);
        if (!leftCells)
          return null;
        const topCells = getCellsInRow(0)(state.selection);
        if (!topCells)
          return null;
        const [topLeft] = leftCells;
        decorations.push(createWidget(ctx, topLeft, ToolTipPos.Point));
        leftCells.forEach((cell, i) => {
          decorations.push(createWidget(ctx, cell, ToolTipPos.Left, i));
        });
        topCells.forEach((cell, i) => {
          decorations.push(createWidget(ctx, cell, ToolTipPos.Top, i));
        });
        return DecorationSet.create(state.doc, decorations);
      }
    },
    view: (editorView) => {
      var _a;
      Object.values(items).forEach(({ $ }) => tooltip.appendChild($));
      (_a = editorView.dom.parentNode) == null ? void 0 : _a.appendChild(tooltip);
      const listener = (e) => {
        if (!editorView)
          return;
        e.stopPropagation();
        e.preventDefault();
        Object.values(items).forEach(({ $, command }) => {
          if ($.contains(e.target)) {
            command(e, editorView)(editorView.state, editorView.dispatch, editorView);
          }
        });
      };
      const hide = () => {
        tooltip.classList.add("hide");
      };
      tooltip.addEventListener("mousedown", listener);
      return {
        update: (view, prevState) => {
          const state = view.state;
          if ((prevState == null ? void 0 : prevState.doc.eq(state.doc)) && prevState.selection.eq(state.selection))
            return;
          const isCellSelection = state.selection instanceof CellSelection;
          if (!isCellSelection || !view.editable) {
            hide();
            return;
          }
          calculateItem(items, view);
          if (Object.values(items).every(({ $ }) => $.classList.contains("hide"))) {
            hide();
            return;
          }
          tooltip.classList.remove("hide");
          calculatePosition(view, tooltip);
        },
        destroy: () => {
          tooltip.removeEventListener("mousedown", listener);
          tooltip.remove();
        }
      };
    }
  });
};
const schema = tableNodes({
  tableGroup: "block",
  cellContent: "paragraph",
  cellAttributes: {
    alignment: {
      default: "left",
      getFromDOM: (dom) => dom.style.textAlign || "left",
      setDOMAttr: (value, attrs) => {
        attrs.style = `text-align: ${value || "left"}`;
      }
    }
  }
});
const proseTableStyle = ({ css }) => css`
    /* copy from https://github.com/ProseMirror/prosemirror-tables/blob/master/style/tables.css */
    .ProseMirror .tableWrapper {
        overflow-x: auto;
    }
    .ProseMirror table {
        border-collapse: collapse;
        table-layout: fixed;
        width: 100%;
        overflow: hidden;
    }
    .ProseMirror td,
    .ProseMirror th {
        vertical-align: top;
        box-sizing: border-box;
        position: relative;
    }
    .ProseMirror .column-resize-handle {
        position: absolute;
        right: -2px;
        top: 0;
        bottom: 0;
        width: 4px;
        z-index: 20;
        background-color: #adf;
        pointer-events: none;
    }
    .ProseMirror.resize-cursor {
        cursor: ew-resize;
        cursor: col-resize;
    }
    /* Give selected cells a blue overlay */
    .ProseMirror .selectedCell:after {
        z-index: 2;
        position: absolute;
        content: '';
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background: rgba(200, 200, 255, 0.4);
        pointer-events: none;
    }
`;
const injectStyle = (utils) => {
  return utils.getStyle(({ size, palette, mixin }, emotion) => {
    var _a, _b, _c;
    const css = emotion.injectGlobal;
    css`
            ${proseTableStyle(emotion)}

            .tableWrapper {
                margin: 0 !important;

                ${(_a = mixin.scrollbar) == null ? void 0 : _a.call(mixin, "x")};

                width: 100%;

                table {
                    width: calc(100% - 2rem) !important;
                    border-radius: ${size.radius};
                    box-sizing: border-box;
                    margin: 1rem 0 1rem 1rem !important;
                    overflow: auto !important;
                    * {
                        margin: 0 !important;
                        box-sizing: border-box;
                        font-size: 1rem;
                    }
                    tr {
                        ${(_b = mixin.border) == null ? void 0 : _b.call(mixin, "bottom")};
                    }

                    th {
                        background: ${palette("background", 0.5)};
                        font-weight: 400;
                    }

                    th,
                    td {
                        min-width: 100px;
                        ${(_c = mixin.border) == null ? void 0 : _c.call(mixin)};
                        text-align: left;
                        position: relative;
                        line-height: 3rem;
                        box-sizing: border-box;
                        height: 3rem;
                    }

                    .selectedCell {
                        &::after {
                            background: ${palette("secondary", 0.38)};
                        }
                        & ::selection {
                            background: transparent;
                        }
                    }

                    .column-resize-handle {
                        background: ${palette("primary")};
                        width: ${size.lineWidth};
                    }

                    th,
                    td {
                        padding: 0 1rem;
                        p {
                            line-height: unset !important;
                        }
                    }

                    .milkdown-cell-left,
                    .milkdown-cell-point,
                    .milkdown-cell-top {
                        position: absolute;

                        &::after {
                            cursor: pointer;
                            position: absolute;
                            top: 0;
                            left: 0;
                            height: 100%;
                            width: 100%;
                            display: block;
                            transition: all 0.2s ease-in-out;
                            background: ${palette("secondary", 0.12)};
                            content: '';
                        }
                        &:hover::after {
                            background: ${palette("secondary", 0.38)};
                        }
                    }

                    .milkdown-cell-left {
                        left: calc(-6px - 0.5rem);
                        top: 0;
                        bottom: 0;
                        width: 0.5rem;
                    }

                    .milkdown-cell-top {
                        left: 0;
                        right: 0;
                        top: calc(-6px - 0.5rem);
                        height: 0.5rem;
                    }

                    .milkdown-cell-point {
                        left: calc(-2px - 1rem);
                        top: calc(-2px - 1rem);
                        width: 1rem;
                        height: 1rem;

                        .icon {
                            position: absolute;
                            top: 0;
                            bottom: 0;
                            left: 0;
                            right: 0;
                        }
                    }
                }
            }
        `;
  });
};
const SupportedKeys$1 = {
  NextCell: "NextCell",
  PrevCell: "PrevCell",
  ExitTable: "ExitTable"
};
const PrevCell = createCmdKey("PrevCell");
const NextCell = createCmdKey("NextCell");
const BreakTable = createCmdKey("BreakTable");
const InsertTable = createCmdKey("InsertTable");
const table = createPlugin((utils) => {
  injectStyle(utils);
  return {
    schema: () => ({
      node: {
        table: __spreadProps(__spreadValues({}, schema.table), {
          parseMarkdown: {
            match: (node) => node.type === "table",
            runner: (state, node, type) => {
              const align = node["align"];
              const children = node.children.map((x, i) => __spreadProps(__spreadValues({}, x), {
                align,
                isHeader: i === 0
              }));
              state.openNode(type);
              state.next(children);
              state.closeNode();
            }
          },
          toMarkdown: {
            match: (node) => node.type.name === "table",
            runner: (state, node) => {
              var _a;
              const firstLine = (_a = node.content.firstChild) == null ? void 0 : _a.content;
              if (!firstLine)
                return;
              const align = [];
              firstLine.forEach((cell) => {
                align.push(cell.attrs["alignment"]);
              });
              state.openNode("table", void 0, { align });
              state.next(node.content);
              state.closeNode();
            }
          }
        }),
        table_row: __spreadProps(__spreadValues({}, schema.table_row), {
          parseMarkdown: {
            match: (node) => node.type === "tableRow",
            runner: (state, node, type) => {
              const align = node["align"];
              const children = node.children.map((x, i) => __spreadProps(__spreadValues({}, x), {
                align: align[i],
                isHeader: node["isHeader"]
              }));
              state.openNode(type);
              state.next(children);
              state.closeNode();
            }
          },
          toMarkdown: {
            match: (node) => node.type.name === "table_row",
            runner: (state, node) => {
              state.openNode("tableRow");
              state.next(node.content);
              state.closeNode();
            }
          }
        }),
        table_cell: __spreadProps(__spreadValues({}, schema.table_cell), {
          parseMarkdown: {
            match: (node) => node.type === "tableCell" && !node["isHeader"],
            runner: (state, node, type) => {
              const align = node["align"];
              state.openNode(type, { alignment: align }).openNode(state.schema.nodes["paragraph"]).next(node.children).closeNode().closeNode();
            }
          },
          toMarkdown: {
            match: (node) => node.type.name === "table_cell",
            runner: (state, node) => {
              state.openNode("tableCell").next(node.content).closeNode();
            }
          }
        }),
        table_header: __spreadProps(__spreadValues({}, schema.table_header), {
          parseMarkdown: {
            match: (node) => node.type === "tableCell" && !!node["isHeader"],
            runner: (state, node, type) => {
              const align = node["align"];
              state.openNode(type, { alignment: align });
              state.openNode(state.schema.nodes["paragraph"]);
              state.next(node.children);
              state.closeNode();
              state.closeNode();
            }
          },
          toMarkdown: {
            match: (node) => node.type.name === "table_header",
            runner: (state, node) => {
              state.openNode("tableCell");
              state.next(node.content);
              state.closeNode();
            }
          }
        })
      }
    }),
    inputRules: (nodeType, ctx) => [
      new InputRule(/^\|\|\s$/, (state, _match, start, end) => {
        const $start = state.doc.resolve(start);
        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType.table))
          return null;
        const tableNode = createTable(ctx.get(schemaCtx));
        const tr = state.tr.replaceRangeWith(start, end, tableNode).scrollIntoView();
        return tr.setSelection(TextSelection.create(tr.doc, start + 3));
      })
    ],
    commands: (_, ctx) => [
      createCmd(PrevCell, () => goToNextCell(-1)),
      createCmd(NextCell, () => goToNextCell(1)),
      createCmd(BreakTable, () => exitTable(ctx.get(schemaCtx).nodes["paragraph"])),
      createCmd(InsertTable, () => (state, dispatch) => {
        const { selection, tr } = state;
        const { from } = selection;
        const table2 = createTable(ctx.get(schemaCtx));
        const _tr = tr.replaceSelectionWith(table2);
        const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true);
        if (sel) {
          dispatch == null ? void 0 : dispatch(_tr.setSelection(sel));
        }
        return true;
      })
    ],
    shortcuts: {
      [SupportedKeys$1.NextCell]: createShortcut(NextCell, "Mod-]"),
      [SupportedKeys$1.PrevCell]: createShortcut(PrevCell, "Mod-["),
      [SupportedKeys$1.ExitTable]: createShortcut(BreakTable, "Mod-Enter")
    },
    prosePlugins: (_, ctx) => {
      return [operatorPlugin(ctx, utils), columnResizing({}), tableEditing()];
    }
  };
});
const SupportedKeys = __spreadProps(__spreadValues(__spreadValues({}, SupportedKeys$2), SupportedKeys$1), {
  StrikeThrough: "StrikeThrough",
  TaskList: "TaskList"
});
const ToggleStrikeThrough = createCmdKey("ToggleStrikeThrough");
const strikeThrough = createMark((utils) => {
  const id = "strike_through";
  const style = utils.getStyle((themeTool, { css }) => css`
                text-decoration-color: ${themeTool.palette("secondary")};
            `);
  return {
    id,
    schema: () => ({
      parseDOM: [
        { tag: "del" },
        { style: "text-decoration", getAttrs: (value) => value === "line-through" }
      ],
      toDOM: (mark) => ["del", { class: utils.getClassName(mark.attrs, "strike-through", style) }],
      parseMarkdown: {
        match: (node) => node.type === "delete",
        runner: (state, node, markType) => {
          state.openMark(markType);
          state.next(node.children);
          state.closeMark(markType);
        }
      },
      toMarkdown: {
        match: (mark) => mark.type.name === id,
        runner: (state, mark) => {
          state.withMark(mark, "delete");
        }
      }
    }),
    inputRules: (markType) => [
      markRule(/(?:~~)([^~]+)(?:~~)$/, markType),
      markRule(/(?:^|[^~])(~([^~]+)~)$/, markType)
    ],
    commands: (markType) => [createCmd(ToggleStrikeThrough, () => toggleMark(markType))],
    shortcuts: {
      [SupportedKeys.StrikeThrough]: createShortcut(ToggleStrikeThrough, "Mod-Alt-x")
    }
  };
});
const SplitTaskListItem = createCmdKey("SplitTaskListItem");
const SinkTaskListItem = createCmdKey("SinkTaskListItem");
const LiftTaskListItem = createCmdKey("LiftTaskListItem");
const TurnIntoTaskList = createCmdKey("TurnIntoTaskList");
const taskListItem = createNode((utils) => {
  const id = "task_list_item";
  const style = utils.getStyle(({ palette, size }, { css }) => css`
                list-style-type: none;
                position: relative;

                & > div {
                    overflow: hidden;
                    padding: 0 2px;
                }

                label {
                    position: absolute;
                    top: 0;
                    left: -2rem;
                    display: inline-block;
                    width: 1.5rem;
                    height: 1.5rem;
                    margin: 0.5rem 0;
                    input {
                        visibility: hidden;
                    }
                }
                label:before {
                    position: absolute;
                    top: 0;
                    right: 0;
                    bottom: 0;
                    left: 0;
                    border-radius: ${size.radius};
                }
                label:hover:before {
                    background: ${palette("background")};
                }
                &[data-checked='true'] {
                    label {
                        color: ${palette("primary")};
                    }
                }
                &[data-checked='false'] {
                    label {
                        color: ${palette("solid", 0.87)};
                    }
                }
                .paragraph {
                    margin: 0.5rem 0;
                }
            `);
  return {
    id,
    schema: () => ({
      group: "listItem",
      content: "paragraph block*",
      defining: true,
      priority: 60,
      attrs: {
        checked: {
          default: false
        }
      },
      parseDOM: [
        {
          tag: 'li[data-type="task-item"]',
          getAttrs: (dom) => {
            if (!(dom instanceof HTMLElement)) {
              throw new Error();
            }
            return { checked: dom.dataset["checked"] === "true" };
          }
        }
      ],
      toDOM: (node) => [
        "li",
        {
          "data-type": "task-item",
          "data-checked": node.attrs["checked"] ? "true" : "false",
          class: utils.getClassName(node.attrs, "task-list-item", style)
        },
        0
      ],
      parseMarkdown: {
        match: ({ type, checked }) => {
          return type === "listItem" && checked !== null;
        },
        runner: (state, node, type) => {
          state.openNode(type, { checked: node["checked"] });
          state.next(node.children);
          state.closeNode();
        }
      },
      toMarkdown: {
        match: (node) => node.type.name === id,
        runner: (state, node) => {
          state.openNode("listItem", void 0, { checked: node.attrs["checked"] });
          state.next(node.content);
          state.closeNode();
        }
      }
    }),
    inputRules: (nodeType) => [
      wrappingInputRule(/^\s*(\[([ |x])\])\s$/, nodeType, (match) => ({
        checked: match[match.length - 1] === "x"
      }))
    ],
    commands: (nodeType) => [
      createCmd(SplitTaskListItem, () => splitListItem(nodeType)),
      createCmd(SinkTaskListItem, () => sinkListItem(nodeType)),
      createCmd(LiftTaskListItem, () => liftListItem(nodeType)),
      createCmd(TurnIntoTaskList, () => wrapIn(nodeType))
    ],
    shortcuts: {
      [SupportedKeys.NextListItem]: createShortcut(SplitTaskListItem, "Enter"),
      [SupportedKeys.SinkListItem]: createShortcut(SinkTaskListItem, "Mod-]"),
      [SupportedKeys.LiftListItem]: createShortcut(LiftTaskListItem, "Mod-["),
      [SupportedKeys.TaskList]: createShortcut(TurnIntoTaskList, "Mod-Alt-9")
    },
    view: (ctx) => (node, view, getPos) => {
      const createIcon = ctx.get(themeToolCtx).slots.icon;
      const listItem2 = document.createElement("li");
      const checkboxWrapper = document.createElement("label");
      const checkboxStyler = document.createElement("span");
      const checkbox = document.createElement("input");
      const content = document.createElement("div");
      let icon = createIcon("unchecked");
      checkboxWrapper.appendChild(icon);
      const setIcon = (name) => {
        const nextIcon = createIcon(name);
        checkboxWrapper.replaceChild(nextIcon, icon);
        icon = nextIcon;
      };
      checkboxWrapper.contentEditable = "false";
      checkbox.type = "checkbox";
      const onChange = (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement))
          return;
        if (!view.editable) {
          checkbox.checked = !checkbox.checked;
          return;
        }
        const { tr } = view.state;
        view.dispatch(tr.setNodeMarkup(getPos(), void 0, {
          checked: target.checked
        }));
      };
      checkbox.addEventListener("change", onChange);
      listItem2.dataset["checked"] = node.attrs["checked"];
      if (node.attrs["checked"]) {
        checkbox.setAttribute("checked", "checked");
      }
      checkboxWrapper.append(checkbox, checkboxStyler);
      listItem2.append(checkboxWrapper, content);
      const attributes = {
        "data-type": "task-item",
        "data-checked": node.attrs["checked"] ? "true" : "false",
        class: utils.getClassName(node.attrs, "task-list-item", style)
      };
      Object.entries(attributes).forEach(([key, value]) => {
        listItem2.setAttribute(key, value);
      });
      setIcon(node.attrs["checked"] ? "checked" : "unchecked");
      return {
        dom: listItem2,
        contentDOM: content,
        update: (updatedNode) => {
          if (updatedNode.type.name !== id)
            return false;
          listItem2.dataset["checked"] = updatedNode.attrs["checked"];
          if (updatedNode.attrs["checked"]) {
            checkbox.setAttribute("checked", "checked");
          } else {
            checkbox.removeAttribute("checked");
          }
          setIcon(updatedNode.attrs["checked"] ? "checked" : "unchecked");
          return true;
        },
        destroy: () => {
          checkbox.removeEventListener("change", onChange);
        }
      };
    }
  };
});
const gfm = AtomList.create([
  ...commonmark,
  $remark(() => remarkGFM),
  table(),
  urlPlugin,
  strikeThrough(),
  taskListItem()
]);
const commands = __spreadProps(__spreadValues({}, commands$1), {
  ToggleStrikeThrough,
  TurnIntoTaskList,
  SinkTaskListItem,
  LiftTaskListItem,
  SplitTaskListItem
});
export { BreakTable, InsertTable, LiftTaskListItem, NextCell, PrevCell, SinkTaskListItem, SplitTaskListItem, SupportedKeys, ToggleStrikeThrough, TurnIntoTaskList, commands, createTable, gfm, strikeThrough, table, taskListItem };
//# sourceMappingURL=index.es.js.map
