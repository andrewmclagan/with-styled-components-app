import { Position } from 'react-markdown';
import { ComponentType, ReactNode } from 'react';
import { AppLinkProps } from '../../../../test/stubs';
import { imageSizes, Panel } from './Markdown';
declare type CustomRendererProp = {
    children?: ReactNode;
    value?: string;
};
declare type CustomRenderer = (args: CustomRendererProp) => ReactNode;
export declare type CustomRenderers = {
    [key: string]: CustomRenderer;
};
declare type HeadingLevel = '1' | '2' | '3' | '4' | '5' | '6';
export declare type NodeAttr = {
    data?: {
        hProperties?: {
            definition?: string;
            size?: keyof typeof imageSizes;
        };
    };
};
export declare type ExtendedNodeAttr = NodeAttr & {
    position: Position;
    type: string;
    value: string;
};
export default function createRenderers(linkComponent: ComponentType<AppLinkProps> | null | undefined, allowedHtml: Array<string>, customRenderers?: CustomRenderers): {
    [x: symbol]: Map<string, NodeAttr> | ((position: Position) => string);
    allowNode: (node: ExtendedNodeAttr) => boolean;
    skipHtml: boolean;
    escapeHtml: boolean;
    parserOptions: {
        commonmark: boolean;
        footnotes: boolean;
    };
    plugins: any[];
    rawSourcePos: boolean;
    renderers: {
        blockquote({ children }: {
            children: ReactNode;
        }): JSX.Element;
        emphasis({ data, children, }: NodeAttr & {
            children: ReactNode;
        }): JSX.Element;
        footnoteReference({ identifier }: {
            identifier: string;
        }): JSX.Element;
        footnoteDefinition({ identifier, children }: {
            children: ReactNode;
            identifier: string;
        }): JSX.Element;
        heading({ level, children }: {
            children: ReactNode;
            level: HeadingLevel;
        }): JSX.Element;
        image({ alt, src, title, sourcePosition, }: NodeAttr & {
            alt?: string | undefined;
            sourcePosition: Position;
            src: string;
            title?: string | undefined;
        }): JSX.Element;
        link({ href, children }: {
            children: ReactNode;
            href: string;
        }): JSX.Element;
        list({ ordered, children }: {
            children: ReactNode;
            ordered: boolean;
        }): JSX.Element;
        listItem({ children }: {
            children: ReactNode;
        }): JSX.Element;
        paragraph({ children }: {
            children: ReactNode;
        }): JSX.Element;
        table({ children }: {
            children: ReactNode;
        }): JSX.Element;
        thematicBreak({ [Math.random()]: props }: {}): JSX.Element;
        math({ value }: {
            value: string;
        }): JSX.Element;
        inlineMath({ value }: {
            value: string;
        }): JSX.Element;
        neonPanel: typeof Panel;
        neonTerms({ children }: {
            children: ReactNode;
        }): JSX.Element;
    };
};
export {};
