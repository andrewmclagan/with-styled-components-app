import { MutableRefObject } from 'react';
import { mount, ShallowWrapper as EnzymeShallowWrapper } from 'enzyme';
import { DeepPartial } from './helpers';
export declare type MockedRef<RefType, MockedCurrent> = MutableRefObject<RefType> & {
    current: MockedCurrent;
};
export declare const MockedForwardRef: <R>(ref: jest.Mock<any, any>) => MutableRefObject<R>;
export declare const TestSymbol: <T>(name: string) => T;
export declare const TestNewSymbol: <T>(name: string) => T;
/**
Force assert a deep partial prop signature into a full one. This allows us to
pass in a partial set of props during tests, even if props are actually
required. This maintains the correct type for the passed props though

**Note**: Only use this for tests

@example
```ts
  // in component
  export type Props = {a: number, b: string, c: HTMLElement,
  }

  // in test
  // props will be of type Props even though they are missing some properties
  const props = MockProps<Props>({a: 1
  });

  const wrapper = shallow(<Component {...props} />);
```
*/
export declare const MockProps: <P>(props: Partial<P>) => P;
export declare const DeepMockProps: <P>(props: DeepPartial<P>) => P;
export declare const MockEvent: <P>(props: Partial<P>) => P;
export declare const DeepMockEvent: <P>(props: DeepPartial<P>) => P;
export declare type Wrapper = ReturnType<typeof mount>;
export declare type ShallowWrapper = EnzymeShallowWrapper<any, any, any>;
export declare type SpiedFunction = ReturnType<typeof jest.spyOn>;
