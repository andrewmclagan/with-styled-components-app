import 'core-js/modules/esnext.map.delete-all.js';
import 'core-js/modules/esnext.map.every.js';
import 'core-js/modules/esnext.map.filter.js';
import 'core-js/modules/esnext.map.find.js';
import 'core-js/modules/esnext.map.find-key.js';
import 'core-js/modules/esnext.map.includes.js';
import 'core-js/modules/esnext.map.key-of.js';
import 'core-js/modules/esnext.map.map-keys.js';
import 'core-js/modules/esnext.map.map-values.js';
import 'core-js/modules/esnext.map.merge.js';
import 'core-js/modules/esnext.map.reduce.js';
import 'core-js/modules/esnext.map.some.js';
import 'core-js/modules/esnext.map.update.js';
import 'core-js/modules/web.dom-collections.iterator.js';
import { KeyboardCode, getClientRect } from '@dnd-kit/core';
import { subtract } from '@dnd-kit/utilities';

// TS: KeyboardEvent stores code as string, widening types
const directions = [
    KeyboardCode.Down,
    KeyboardCode.Right,
    KeyboardCode.Up,
    KeyboardCode.Left, 
];
// Custom coordinate getter for DragAndDropQuestion. It finds the next/previous
// droppable blank area available when using the keyboard.
// https://docs.dndkit.com/presets/sortable#sensors
const droppableCoordinateGetter = (answersBankId)=>{
    return (event, param1)=>{
        let { context ,  } = param1;
        if (directions.includes(event.code)) {
            event.preventDefault();
            const { droppableContainers , over  } = context;
            const activeDroppables = new Map([
                ...droppableContainers
            ].filter((param)=>{
                let [, value] = param;
                return !value.disabled;
            }));
            const withAllBlanksFilled = activeDroppables.size === 1;
            if (withAllBlanksFilled || !over) {
                return undefined;
            }
            const activeDroppablesIds = Array.from(activeDroppables.keys());
            const currentDroppableIndex = activeDroppablesIds.indexOf(over.id);
            var ref;
            const nextDroppableId = (ref = activeDroppablesIds[currentDroppableIndex + 1]) !== null && ref !== void 0 ? ref : answersBankId;
            var ref1;
            const previousDroppableId = (ref1 = activeDroppablesIds[currentDroppableIndex - 1]) !== null && ref1 !== void 0 ? ref1 : answersBankId;
            let closestDroppableId;
            switch(event.code){
                case KeyboardCode.Down:
                    closestDroppableId = nextDroppableId;
                    break;
                case KeyboardCode.Up:
                    closestDroppableId = previousDroppableId;
                    break;
                case KeyboardCode.Left:
                    closestDroppableId = previousDroppableId;
                    break;
                case KeyboardCode.Right:
                    closestDroppableId = nextDroppableId;
                    break;
            }
            if (closestDroppableId) {
                var ref2, ref3;
                const newNode = (ref2 = droppableContainers.get(closestDroppableId)) === null || ref2 === void 0 ? void 0 : (ref3 = ref2.node) === null || ref3 === void 0 ? void 0 : ref3.current;
                // offset the selected draggable on the bank droppable so that it doesn't
                // fully hide any other draggable
                const offset = closestDroppableId === answersBankId ? 20 : 0;
                if (newNode) {
                    const newRect = getClientRect(newNode);
                    const newCoordinates = subtract({
                        x: newRect.left + offset,
                        y: newRect.top + offset
                    });
                    return newCoordinates;
                }
            }
        }
        return undefined;
    };
};

export { droppableCoordinateGetter };
