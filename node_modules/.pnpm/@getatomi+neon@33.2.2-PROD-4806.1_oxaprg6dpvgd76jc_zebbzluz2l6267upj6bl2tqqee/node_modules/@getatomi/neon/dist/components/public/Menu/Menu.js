import 'core-js/modules/web.dom-collections.iterator.js';
import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { useRef, useState, useCallback, cloneElement, forwardRef } from 'react';
import { Menu as Menu$1, MenuItems, MenuItem, useMenuButtonContext, MenuPopover as MenuPopover$1, MenuButton as MenuButton$1 } from '@reach/menu-button';
import keyMirror from 'keymirror';
import _ from 'lodash';
import cx from 'classnames';
import { breakpoints } from '../../../constants/tokens/breakpoints.js';
import Drawer from '../Drawer/Drawer.js';
import Icon from '../Icon/Icon.js';
import MenuItem$1, { variants } from '../MenuItem/MenuItem.js';
import { useMedia } from '../Media/Media.js';
import { useKeyDown } from '../../../utils/a11y.js';
import useId from '../../../utils/useId.js';
import styles from './Menu.css.js';

const breakpoint = {
    minWidth: breakpoints.breakpointMediumFrom
};
keyMirror({
    vertical: null
});
const optionToProps = (param)=>{
    let { label , ...props } = param;
    return {
        ...props,
        children: label,
        withSeparator: undefined
    };
};
// Access the Reach MenuButton context to only render the MenuPopover when it's
// actually open. This ensures it can be used within a Modal without being
// incorrectly given aria-hidden when the modal opens.
// See https://github.com/reach/reach-ui/issues/870 for more.
function MenuPopover(props) {
    const { isExpanded  } = useMenuButtonContext();
    return isExpanded ? jsx(MenuPopover$1, Object.assign({}, props), void 0) : null;
}
const MenuButton = /*#__PURE__*/ forwardRef(function MenuButton(props, ref) {
    const { isExpanded  } = useMenuButtonContext();
    return jsx(MenuButton$1, Object.assign({
        ref: ref
    }, props, isExpanded ? {} : {
        'aria-controls': undefined
    }), void 0);
});
function Menu(props) {
    const { ariaLabel , drawerProps , iconName ='menu-more' , trigger , itemVariant =variants.narrow , items , popoverPosition , isDisabled , variant , testHook , ...otherProps } = props;
    // Generate a default id for the MenuButton to work around the issue with the
    // reach-ui/dropdown lib: https://github.com/reach/reach-ui/pull/970.
    const autoId = useId('Menu');
    var _id;
    const menuButtonId = (_id = props.id) !== null && _id !== void 0 ? _id : autoId;
    const buttonRef = useRef(null);
    const [isDrawerOpen, setIsDrawerOpen] = useState(false);
    const matches = useMedia(breakpoint);
    const handleClick = useCallback((event)=>{
        // don't show the menu list when we need to show the drawer
        if (!matches) {
            event.preventDefault();
            setIsDrawerOpen(true);
        }
    }, [
        matches
    ]);
    const handleKeyDown = useKeyDown(handleClick);
    const drawerOnClose = useCallback(()=>{
        var ref, ref1;
        setIsDrawerOpen(false);
        drawerProps === null || drawerProps === void 0 ? void 0 : (ref = drawerProps.onClose) === null || ref === void 0 ? void 0 : ref.call(drawerProps); // eslint-disable-line no-unused-expressions
        (ref1 = buttonRef.current) === null || ref1 === void 0 ? void 0 : ref1.focus(); // eslint-disable-line no-unused-expressions
    }, [
        drawerProps
    ]);
    return jsxs(Fragment, {
        children: [
            jsxs(Menu$1, {
                children: [
                    jsx(MenuButton, Object.assign({}, otherProps, {
                        ref: buttonRef,
                        id: menuButtonId,
                        className: cx(styles.button, {
                            [styles.withIcon]: !trigger
                        }),
                        "aria-label": ariaLabel,
                        onKeyDown: handleKeyDown,
                        onMouseDown: handleClick,
                        disabled: isDisabled,
                        "data-test": testHook && `${testHook}-trigger`
                    }, {
                        children: trigger || jsx(Icon, {
                            name: variant === 'vertical' ? 'menu-kebab' : iconName
                        }, void 0)
                    }), void 0),
                    jsx(MenuPopover, Object.assign({
                        className: cx(styles.popover, {
                            [styles.withPosition]: popoverPosition
                        }),
                        position: popoverPosition,
                        onKeyDown: (event)=>{
                            if (event.key === 'Escape') {
                                // prevent event from bubbling up e.g. when used in a modal
                                event.stopPropagation();
                            }
                        }
                    }, {
                        children: jsx(MenuItems, Object.assign({
                            className: styles.menu
                        }, {
                            children: items.map((param, i // TODO: focus active item on mount
                            )=>{
                                let { onSelect , ...item } = param;
                                return(// https://www.w3.org/TR/wai-aria-practices-1.2/#listbox_kbd_interaction
                                jsx(MenuItem, Object.assign({
                                    className: styles.menuItem,
                                    onSelect: onSelect,
                                    "data-test": testHook && `${testHook}-item-${i}`
                                }, {
                                    children: jsx(MenuItem$1, Object.assign({}, optionToProps(item), {
                                        variant: itemVariant
                                    }), void 0)
                                }), i));
                            })
                        }), void 0)
                    }), void 0)
                ]
            }, void 0),
            jsx(Drawer, Object.assign({}, drawerProps, {
                ariaLabel: "Menu drawer",
                isOpen: isDrawerOpen,
                onClose: drawerOnClose,
                testHook: testHook && `${testHook}-drawer`
            }, {
                children: jsx(Drawer.Content, {
                    children: items.map((param, i // TODO: focus active item on mount
                    )=>{
                        let { onSelect , ...item } = param;
                        return(// https://www.w3.org/TR/wai-aria-practices-1.2/#listbox_kbd_interaction
                        jsx(Drawer.Item, Object.assign({
                            onClick: ()=>{
                                onSelect();
                                setIsDrawerOpen(false);
                            },
                            withSeparator: item.withSeparator != null ? item.withSeparator : true,
                            testHook: testHook && `${testHook}-list-item-${i}`
                        }, {
                            children: jsx(MenuItem$1, Object.assign({}, optionToProps(item), {
                                withActiveIcon: true
                            }), void 0)
                        }), i));
                    })
                }, void 0)
            }), void 0)
        ]
    }, void 0);
}
Menu.Item = MenuItem$1;
function StatefulMenu(props) {
    const { isDisabled , placeholder , trigger , options , value , onChange , testHook , ...otherProps } = props;
    const placeholderOption = placeholder ? {
        label: placeholder,
        value: null,
        isDisabled: true
    } : null;
    const optionsWithPlaceholder = placeholderOption ? [
        placeholderOption,
        ...options
    ] : options;
    // TODO-TS not sure if `as OptionWithValue` is the correct assertion here.., what is providerOption?
    const providedOption = _.find(optionsWithPlaceholder, {
        value
    }) || optionsWithPlaceholder[0];
    // decide between controlled or uncontrolled behaviour
    const [internalState, setCurrent] = useState(providedOption);
    const current = typeof value === 'undefined' ? internalState : providedOption;
    const currentItem = jsx(MenuItem$1, Object.assign({}, optionToProps(current)), void 0);
    return jsx(Menu, Object.assign({}, otherProps, {
        trigger: trigger ? /*#__PURE__*/ cloneElement(trigger, {
            isDisabled
        }, currentItem) : currentItem,
        items: optionsWithPlaceholder.map((option)=>({
                ...option,
                isActive: option.value === current.value,
                onSelect () {
                    setCurrent(option);
                    onChange(option.value);
                }
            })
        ),
        isDisabled: isDisabled,
        testHook: testHook
    }), void 0);
}

export { StatefulMenu, Menu as default };
