import 'core-js/modules/web.dom-collections.iterator.js';
import { jsxs, jsx, Fragment } from 'react/jsx-runtime';
import { forwardRef, useRef, useState, useCallback } from 'react';
import useMergedRef from '@react-hook/merged-ref';
import useOnClickOutside from 'use-onclickoutside';
import cx from 'classnames';
import { Combobox, ComboboxInput, ComboboxPopover, ComboboxList, ComboboxOption, ComboboxOptionText } from '@reach/combobox';
import FieldResetButton from '../../private/FieldResetButton/FieldResetButton.js';
import Truncate from '../Truncate/Truncate.js';
import useFormField from '../../private/FormField/FormField.js';
import SearchInput from '../../private/SearchInput/SearchInput.js';
import Box from '../Box/Box.js';
import MenuItem from '../MenuItem/MenuItem.js';
import TextField from '../TextField/TextField.js';
import Drawer from '../Drawer/Drawer.js';
import { breakpoints } from '../../../constants/tokens/breakpoints.js';
import { useMedia } from '../Media/Media.js';
import { popoverPosition } from '../../../utils/popoverPositions.js';
import styles from './Autosuggest.css.js';

function NoResultMenuItem(props) {
    const { children , variant  } = props;
    return jsx(MenuItem, Object.assign({
        variant: variant
    }, {
        children: jsx(Box, Object.assign({
            as: "span",
            role: "alert"
        }, {
            children: children
        }), void 0)
    }), void 0);
}
const Autosuggest = /*#__PURE__*/ forwardRef(function Autosuggest(props, ref1) {
    const { buttonText , drawerProps , helpText , isDisabled , isRequired , label , options , onBlur , onReset , onSearchReset , onSelect , noResultText , renderAddOptionText , secondaryLabel , testHook , validationText , value , errorVariant , ...otherProps } = props;
    const textFieldContainerRef = useRef(null);
    const textFieldRef = useRef(null);
    const textFieldMergedRef = useMergedRef(ref1, textFieldRef);
    const matches = useMedia({
        minWidth: breakpoints.breakpointMediumFrom
    });
    const [isDrawerOpen, setIsDrawerOpen] = useState(false);
    // There is an issue in Comobox: https://github.com/reach/reach-ui/issues/792
    // When selecting an option, onBlur is triggered before onSelect which makes
    // it impossible to decide if the input field can be cleared. Using this hook,
    // onBlur is only called when the user didn't select an option.
    useOnClickOutside(textFieldRef, (e)=>{
        var ref;
        // TODO-TS[ENHANCEMENT] requires behaviour change - remove `as HTMLElement`
        // assertion and null check as e.target can be null
        const selectedOption = ((ref = e.target.closest('li')) === null || ref === void 0 ? void 0 : ref.getAttribute('role')) === 'option';
        if (matches && !selectedOption && document.activeElement === textFieldRef.current) {
            onBlur();
        }
    });
    const handleReset = ()=>{
        var ref;
        if (!onReset) {
            return;
        }
        onReset();
        (ref = textFieldRef.current) === null || ref === void 0 ? void 0 : ref.focus();
    };
    const showNoResultMenuItem = !options.length && !renderAddOptionText;
    const showAddOption = useCallback(()=>{
        const optionLabels = options.map((option)=>option.label.toLowerCase()
        );
        const isNotInOptions = !optionLabels.includes(value === null || value === void 0 ? void 0 : value.toLowerCase());
        return !!(isNotInOptions && renderAddOptionText && value);
    }, [
        options,
        renderAddOptionText,
        value
    ]);
    const onDrawerOpen = useCallback(()=>{
        var ref;
        setIsDrawerOpen(true);
        drawerProps === null || drawerProps === void 0 ? void 0 : (ref = drawerProps.onOpen) === null || ref === void 0 ? void 0 : ref.call(drawerProps);
    }, [
        drawerProps
    ]);
    const onDrawerClose = useCallback(()=>{
        var ref;
        setIsDrawerOpen(false);
        onBlur();
        drawerProps === null || drawerProps === void 0 ? void 0 : (ref = drawerProps.onClose) === null || ref === void 0 ? void 0 : ref.call(drawerProps);
    }, [
        drawerProps,
        onBlur
    ]);
    const onDrawerSelect = useCallback((option)=>{
        var ref;
        onSelect(option);
        setIsDrawerOpen(false);
        drawerProps === null || drawerProps === void 0 ? void 0 : (ref = drawerProps.onClose) === null || ref === void 0 ? void 0 : ref.call(drawerProps);
    }, [
        drawerProps,
        onSelect
    ]);
    const { classnames , containerClassnames , fieldAttributes , fieldClassnames , fieldHelpText , fieldLabel ,  } = useFormField({
        label,
        helpText,
        isDisabled,
        isRequired,
        validationText,
        errorVariant,
        secondaryLabel,
        testHook
    });
    return jsxs(Box, Object.assign({
        testHook: testHook
    }, {
        children: [
            fieldLabel,
            matches ? jsxs(Combobox, Object.assign({
                className: cx({
                    [styles.withChevron]: !renderAddOptionText,
                    [styles.withTextFade]: !renderAddOptionText,
                    [styles.isDisabled]: isDisabled
                }),
                onSelect: onSelect,
                openOnFocus: !renderAddOptionText
            }, {
                children: [
                    jsx(ComboboxInput, Object.assign({}, otherProps, fieldAttributes, {
                        as: TextField,
                        containerRef: textFieldContainerRef,
                        insertAfter: onReset && jsx(FieldResetButton, {
                            marginRight: renderAddOptionText ? undefined : 'spacingLarge1X',
                            onClick: handleReset,
                            testHook: testHook && `${testHook}-field-reset-button`
                        }, void 0),
                        isDisabled: isDisabled,
                        ref: textFieldMergedRef,
                        testHook: testHook && `${testHook}-input`,
                        value: value,
                        errorVariant: errorVariant,
                        withVariantIcon: false
                    }), void 0),
                    jsx(ComboboxPopover, Object.assign({
                        className: styles.popover,
                        // @ts-ignore TODO-TS[ENHANCEMENT] position seems to vary from component to component
                        position: popoverPosition({
                            targetContainer: textFieldContainerRef
                        })
                    }, {
                        children: jsxs(ComboboxList, Object.assign({
                            className: styles.list
                        }, {
                            children: [
                                showAddOption() && // @ts-ignore TODO-TS
                                jsx(ComboboxOption, Object.assign({
                                    className: styles.listItem,
                                    value: value
                                }, {
                                    children: jsx(MenuItem, Object.assign({
                                        variant: "large",
                                        testHook: testHook && `${testHook}-item-addOption`
                                    }, {
                                        children: jsx(Fragment, {
                                            children: renderAddOptionText && renderAddOptionText(jsx(ComboboxOptionText, {}, void 0))
                                        }, void 0)
                                    }), void 0)
                                }), void 0),
                                options.length > 0 && jsx(Fragment, {
                                    children: options.map((option, i)=>jsx(ComboboxOption, Object.assign({
                                            className: styles.listItem,
                                            value: option.label
                                        }, {
                                            children: jsx(MenuItem, Object.assign({}, option, {
                                                variant: "large",
                                                testHook: testHook && `${testHook}-item-${i}`
                                            }, {
                                                children: jsx(ComboboxOptionText, {}, void 0)
                                            }), void 0)
                                        }), i)
                                    )
                                }, void 0),
                                showNoResultMenuItem && jsx(NoResultMenuItem, Object.assign({
                                    variant: "large"
                                }, {
                                    children: noResultText
                                }), void 0)
                            ]
                        }), void 0)
                    }), void 0)
                ]
            }), void 0) : jsx(Box, Object.assign({
                className: cx(containerClassnames, {
                    [styles.isDisabled]: isDisabled,
                    [styles.withChevron]: !renderAddOptionText
                })
            }, {
                children: jsx("button", Object.assign({
                    disabled: fieldAttributes.disabled,
                    className: cx(styles.drawerTrigger, fieldClassnames, classnames),
                    onClick: onDrawerOpen,
                    type: "button",
                    "data-test": testHook && `${testHook}-trigger`
                }, {
                    children: jsx(Truncate, Object.assign({
                        paddingRight: !renderAddOptionText ? 'spacingLarge1X' : undefined,
                        color: !value ? 'colorFiftyShadesDark' : undefined
                    }, {
                        children: value || buttonText
                    }), void 0)
                }), void 0)
            }), void 0),
            fieldHelpText,
            isDrawerOpen && jsxs(Drawer, Object.assign({}, drawerProps, {
                variant: "fullHeight",
                isOpen: isDrawerOpen,
                onClose: onDrawerClose,
                testHook: testHook && `${testHook}-drawer`
            }, {
                children: [
                    jsx(Drawer.Header, {
                        children: jsx(Drawer.CloseButton, {
                            onClick: onDrawerClose,
                            testHook: testHook && `${testHook}-close`
                        }, void 0)
                    }, void 0),
                    jsx(Drawer.Content, Object.assign({
                        withPadding: false
                    }, {
                        children: jsxs(Combobox, Object.assign({
                            onSelect: onDrawerSelect
                        }, {
                            children: [
                                jsx(Drawer.Item, Object.assign({
                                    fadedOut: true
                                }, {
                                    children: jsx(SearchInput, Object.assign({}, otherProps, {
                                        value: value,
                                        autoFocus: true,
                                        onReset: onSearchReset,
                                        testHook: testHook && `${testHook}-search-input`,
                                        as: ComboboxInput
                                    }), void 0)
                                }), void 0),
                                jsxs(ComboboxList, Object.assign({
                                    className: styles.list
                                }, {
                                    children: [
                                        showAddOption() && jsx(ComboboxOption, Object.assign({
                                            as: Drawer.Item,
                                            element: "li",
                                            onClick: ()=>onDrawerSelect(value)
                                            ,
                                            className: styles.listItem,
                                            // @ts-ignore TODO-TS
                                            value: value,
                                            "data-test": testHook && `${testHook}-item-addOption`
                                        }, {
                                            children: renderAddOptionText && // @ts-ignore Box being reworked - see box notes
                                            jsx("div", {
                                                children: renderAddOptionText(jsx(ComboboxOptionText, {}, void 0))
                                            }, void 0)
                                        }), void 0),
                                        options.length > 0 && jsx(Fragment, {
                                            children: options.map((option, i)=>jsx(ComboboxOption, Object.assign({
                                                    as: Drawer.Item,
                                                    element: "li",
                                                    value: option.label,
                                                    "data-test": testHook && `${testHook}-item-${i}`
                                                }, {
                                                    children: jsx(MenuItem, Object.assign({}, option, {
                                                        children: jsx(ComboboxOptionText, {}, void 0)
                                                    }), void 0)
                                                }), i)
                                            )
                                        }, void 0),
                                        showNoResultMenuItem && jsx(Drawer.Item, {
                                            children: jsx(NoResultMenuItem, {
                                                children: noResultText
                                            }, void 0)
                                        }, void 0)
                                    ]
                                }), void 0)
                            ]
                        }), void 0)
                    }), void 0)
                ]
            }), void 0)
        ]
    }), void 0);
});

export { Autosuggest as default };
