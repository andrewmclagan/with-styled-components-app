import 'core-js/modules/web.dom-collections.iterator.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useState, useMemo, cloneElement } from 'react';
import cx from 'classnames';
import Button from '../Button/Button.js';
import Container from '../Container/Container.js';
import Icon from '../Icon/Icon.js';
import Markdown from '../Markdown/Markdown.js';
import { useMedia } from '../Media/Media.js';
import Select from '../Select/Select.js';
import QuizQuestion from './QuizQuestion.js';
import styles from './SelfMarkedQuestion.css.js';

function CheckButton(props) {
    const { backLabel , checkLabel , isReversed , isChecking , onClick , testHook , ...otherProps } = props;
    return jsxs("button", Object.assign({}, otherProps, {
        type: "button",
        className: cx(styles.check, isReversed && styles.reverse),
        onClick: onClick,
        "data-test": testHook
    }, {
        children: [
            isChecking ? backLabel : checkLabel,
            jsx("span", Object.assign({
                className: styles.icon
            }, {
                children: jsx(Icon, {
                    name: "action-flip",
                    size: "sizeIconSmall"
                }, void 0)
            }), void 0)
        ]
    }), void 0);
}
function CardWrapper(props) {
    const { isAriaHidden , isGuidelines , checkButton , children  } = props;
    const matches = useMedia({
        query: styles['--breakpoint']
    });
    // hide and prevent focus on interactive elements
    const ariaProps = {
        'aria-hidden': isAriaHidden,
        tabIndex: isAriaHidden ? -1 : undefined
    };
    // the spacer exists so the content can be scrolled to the bottom
    const spacer = jsx("div", {
        className: styles.spacer,
        "aria-hidden": true
    }, void 0);
    return jsx("div", Object.assign({
        className: cx(styles.cardWrapper, isGuidelines && styles.flipped)
    }, ariaProps, {
        children: !matches ? jsxs("div", Object.assign({
            className: styles.card
        }, {
            children: [
                jsxs("div", Object.assign({
                    className: styles.content
                }, ariaProps, {
                    children: [
                        children,
                        spacer
                    ]
                }), void 0),
                jsx("div", Object.assign({
                    className: styles.action
                }, {
                    children: /*#__PURE__*/ cloneElement(checkButton, ariaProps)
                }), void 0)
            ]
        }), void 0) : jsx("div", Object.assign({
            className: styles.content
        }, {
            children: jsxs(Container, Object.assign({
                maxWidth: "sizeRoot"
            }, {
                children: [
                    children,
                    isGuidelines && spacer
                ]
            }), void 0)
        }), void 0)
    }), void 0);
}
function SelfMarkedQuestion(props) {
    const { checkButtonProps , isChecking , guidelines , testHook , marks , renderMarks , ...questionProps } = props;
    // These components are expensive to re-render because they render Markdown
    // and they trigger a re-render of the entire tree. Because of that, on mobile
    // the scroll position is lost when flipping between the front and back card.
    const questionMemo = useMemo(()=>jsx(QuizQuestion, Object.assign({}, questionProps, {
            meta: renderMarks(jsx("strong", {
                children: marks
            }, void 0)),
            illustrationName: "main-writing",
            testHook: testHook && `${testHook}-question`
        }), void 0)
    , // the title is enough to detect a new question -- if we put `questionProps`
    // it will always recreate the component because `questionProps` is always
    // new (using ...rest syntax)
    [
        questionProps.title,
        testHook
    ] // eslint-disable-line react-hooks/exhaustive-deps
    );
    const guidelinesMemo = useMemo(()=>jsx(Markdown, Object.assign({
            linkComponent: questionProps.linkComponent,
            testHook: testHook && `${testHook}-guidelines`
        }, {
            children: guidelines
        }), void 0)
    , // same reasoning as for `questionMemo`
    [
        guidelines,
        testHook
    ] // eslint-disable-line react-hooks/exhaustive-deps
    );
    return jsx("div", Object.assign({
        className: styles.root
    }, {
        children: jsxs("div", Object.assign({
            className: cx(styles.stack, isChecking && styles.flipped)
        }, {
            children: [
                jsx(CardWrapper, Object.assign({
                    checkButton: jsx(CheckButton, Object.assign({}, checkButtonProps, {
                        testHook: testHook && `${testHook}-check-question`
                    }), void 0),
                    isAriaHidden: isChecking
                }, {
                    children: questionMemo
                }), void 0),
                jsx(CardWrapper, Object.assign({
                    checkButton: jsx(CheckButton, Object.assign({}, checkButtonProps, {
                        isChecking: true,
                        testHook: testHook && `${testHook}-check-guidelines`
                    }), void 0),
                    isGuidelines: true,
                    isAriaHidden: !isChecking
                }, {
                    children: guidelinesMemo
                }), void 0)
            ]
        }), void 0)
    }), void 0);
}
function useSelfMarkedQuestion(props) {
    const { checkLabel , backLabel , guidelines , selectLabel , selectOptions , submitText , onSubmit , testHook , ...questionProps } = props;
    const [isChecking, setIsChecking] = useState(false);
    const [value, setValue] = useState(selectOptions[0].value);
    if (!guidelines) {
        return {
            footer: undefined,
            question: null
        };
    }
    const formOnSubmit = (event)=>{
        event.preventDefault();
        onSubmit(value);
    };
    const checkButtonProps = {
        checkLabel,
        backLabel,
        onClick () {
            setIsChecking((checking)=>!checking
            );
        }
    };
    return {
        question: jsx(SelfMarkedQuestion, Object.assign({}, questionProps, {
            checkButtonProps: checkButtonProps,
            isChecking: isChecking,
            guidelines: guidelines,
            testHook: testHook
        }), void 0),
        footer: [
            jsx(CheckButton, Object.assign({}, checkButtonProps, {
                isChecking: isChecking,
                isReversed: true,
                testHook: testHook && `${testHook}-check`
            }), void 0),
            jsxs("form", Object.assign({
                className: styles.form,
                onSubmit: formOnSubmit
            }, {
                children: [
                    jsx("div", Object.assign({
                        className: styles.select
                    }, {
                        children: jsx(Select, {
                            trigger: jsx(Select.DeprecatedTrigger, {}, void 0),
                            label: selectLabel,
                            options: selectOptions,
                            value: value,
                            onChange: setValue,
                            testHook: testHook && `${testHook}-select`
                        }, void 0)
                    }), void 0),
                    jsx(Button, Object.assign({
                        size: "small",
                        type: "submit",
                        testHook: testHook && `${testHook}-submit`
                    }, {
                        children: submitText
                    }), void 0)
                ]
            }), void 0), 
        ]
    };
}

export { SelfMarkedQuestion, useSelfMarkedQuestion as default };
