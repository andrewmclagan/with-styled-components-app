import 'core-js/modules/esnext.map.delete-all.js';
import 'core-js/modules/esnext.map.every.js';
import 'core-js/modules/esnext.map.filter.js';
import 'core-js/modules/esnext.map.find.js';
import 'core-js/modules/esnext.map.find-key.js';
import 'core-js/modules/esnext.map.includes.js';
import 'core-js/modules/esnext.map.key-of.js';
import 'core-js/modules/esnext.map.map-keys.js';
import 'core-js/modules/esnext.map.map-values.js';
import 'core-js/modules/esnext.map.merge.js';
import 'core-js/modules/esnext.map.reduce.js';
import 'core-js/modules/esnext.map.some.js';
import 'core-js/modules/esnext.map.update.js';
import 'core-js/modules/web.dom-collections.iterator.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import cx from 'classnames';
import { BlockMath, InlineMath } from 'react-katex';
import remarkAttr from 'remark-attr';
import remarkMacroBuilder from 'remark-macro';
import remarkMath from 'remark-math';
import remarkTerms from 'remark-terms';
import remarkUnwrapImages from 'remark-unwrap-images';
import flattenChildren from 'react-flatten-children';
import { counter } from '../../../utils/counter.js';
import Markdown, { Definition, Link, Image, imageSizes, Panel, DragAndDrop } from './Markdown.js';
import markdownStyles from './Markdown.css.js';

const panelNodeName = 'neonPanel';
const termsNodeName = 'neonTerms';
const remarkMacro = remarkMacroBuilder();
// @ts-ignore TODO-TS
remarkMacro.addMacro('panel', (content, props, param)=>{
    let { transformer , eat  } = param;
    return {
        type: panelNodeName,
        variant: props.type,
        children: transformer.tokenizeBlock(content, eat.now())
    };
});
// We always have at least one child, so no need for null checks. A paragraph's children are
// rendered by `TextRenderer` so we need to take the children of the last `TextRenderer` element.
// https://github.com/remarkjs/react-markdown/blob/v4.3.1/src/renderers.js#L29
function lastDescendant(children) {
    const childrenArray = flattenChildren(children);
    const lastChild = childrenArray.pop();
    if (typeof lastChild === 'string') return lastChild;
    // @ts-ignore as per the comment above. can we rework this so it isn't a type error though?
    return lastChild && lastDescendant(lastChild.props.children);
}
function createRenderers(linkComponent, allowedHtml, customRenderers) {
    // `react-markdown` (current version: 4.3.1) doesn't expose the AST nodes so
    // we have to save our own references
    // https://github.com/arobase-che/remark-attr/issues/16#issuecomment-577487013
    const imageNodes = new Map();
    // generate a unique id for each occurence of the a drag-and-drop answer
    const counterDragAndDrop = counter();
    const nodeKey = (position)=>{
        return JSON.stringify(position === null || position === void 0 ? void 0 : position.start);
    };
    // node value appears twice: once for the opening tag and once for the closing tag
    // (<cite> and </cite>), so we have to allow both
    const allowedHtmlRegex = allowedHtml.map((allowedTag)=>new RegExp(`^</?${allowedTag}>$`)
    );
    /**
     * Function executed in order to determine if the node should be allowed. Ran
     * prior to checking allowedTypes/disallowedTypes. Returning a truthy value will
     * allow the node to be included.
     *
     * Note that if this function returns true and the type is not in `allowedTypes`
     * (or if it's in `disallowedTypes`), it won't be included.
     */ function allowNode(node) {
        if (node.type === 'image') {
            imageNodes.set(nodeKey(node.position), node);
        } else if (node.type === 'html') {
            return allowedHtmlRegex.some((regex)=>regex.test(node.value)
            );
        }
        return true;
    }
    let renderers = {
        blockquote (param) {
            let { children  } = param;
            return jsx("blockquote", Object.assign({
                className: markdownStyles.blockquote
            }, {
                children: children
            }), void 0);
        },
        emphasis (param) {
            let { data , children ,  } = param;
            var ref;
            return (data === null || data === void 0 ? void 0 : (ref = data.hProperties) === null || ref === void 0 ? void 0 : ref.definition) ? jsx(Definition, Object.assign({
                definition: jsx(Markdown, Object.assign({
                    linkComponent: linkComponent,
                    isLimited: true
                }, {
                    children: data.hProperties.definition
                }), void 0)
            }, {
                children: children
            }), void 0) : jsx("em", Object.assign({
                className: markdownStyles.em
            }, {
                children: children
            }), void 0);
        },
        footnoteReference (param) {
            let { identifier  } = param;
            return jsx(Link, Object.assign({
                component: linkComponent,
                id: `fnref-${identifier}`,
                to: `#fndef-${identifier}`
            }, {
                children: jsx("sup", Object.assign({
                    className: markdownStyles.footnoteReference
                }, {
                    children: identifier
                }), void 0)
            }), void 0);
        },
        footnoteDefinition (param) {
            let { identifier , children  } = param;
            return jsxs("div", Object.assign({
                className: markdownStyles.footnoteDefinition
            }, {
                children: [
                    jsx(Link, Object.assign({
                        component: linkComponent,
                        id: `fndef-${identifier}`,
                        className: markdownStyles.link,
                        to: `#fnref-${identifier}`
                    }, {
                        children: identifier
                    }), void 0),
                    children
                ]
            }), void 0);
        },
        heading (param) {
            let { level , children  } = param;
            const Heading = `h${level}`;
            return jsx(Heading, Object.assign({
                className: cx(markdownStyles.heading, markdownStyles[`h${level}`])
            }, {
                children: children
            }), void 0);
        },
        image (param) {
            let { alt , src , title , sourcePosition ,  } = param;
            var ref, ref1;
            const node = imageNodes.get(nodeKey(sourcePosition));
            const size = node === null || node === void 0 ? void 0 : (ref = node.data) === null || ref === void 0 ? void 0 : (ref1 = ref.hProperties) === null || ref1 === void 0 ? void 0 : ref1.size;
            return jsxs("figure", Object.assign({
                className: markdownStyles.image
            }, {
                children: [
                    jsx(Image, {
                        size: size ? imageSizes[size] : undefined,
                        alt: alt,
                        src: src
                    }, void 0),
                    title && jsx("figcaption", Object.assign({
                        className: markdownStyles.caption
                    }, {
                        children: title
                    }), void 0)
                ]
            }), void 0);
        },
        link (param) {
            let { href , children  } = param;
            return jsx(Link, Object.assign({
                component: linkComponent,
                href: href,
                isExternal: true
            }, {
                children: children
            }), void 0);
        },
        list (param) {
            let { ordered , children  } = param;
            const ListEl = ordered ? 'ol' : 'ul';
            return jsx(ListEl, Object.assign({
                className: markdownStyles[ListEl]
            }, {
                children: children
            }), void 0);
        },
        listItem (param) {
            let { children  } = param;
            return jsx("li", Object.assign({
                className: markdownStyles.li
            }, {
                children: children
            }), void 0);
        },
        paragraph (param) {
            let { children  } = param;
            return jsx("p", Object.assign({
                className: cx(markdownStyles.paragraph, {
                    [markdownStyles.collapse]: String(lastDescendant(children)).endsWith(':')
                })
            }, {
                children: children
            }), void 0);
        },
        table (param) {
            let { children  } = param;
            return jsx("div", Object.assign({
                className: markdownStyles.tableWrapper
            }, {
                children: jsx("table", Object.assign({
                    className: markdownStyles.table
                }, {
                    children: children
                }), void 0)
            }), void 0);
        },
        // @ts-ignore TODO-TS
        thematicBreak (param) {
            let { [Math.random()]: props  } = param;
            // this avoids ThematicBreak to be hoisted and break when
            // babel-plugin-transform-react-constant-elements runs
            return jsx("hr", Object.assign({
                className: markdownStyles.hr
            }, props), void 0);
        },
        math (param) {
            let { value  } = param;
            return jsx(BlockMath, {
                children: value
            }, void 0);
        },
        inlineMath (param) {
            let { value  } = param;
            return jsx(InlineMath, {
                children: value
            }, void 0);
        },
        [panelNodeName]: Panel,
        [termsNodeName] (param) {
            let { children  } = param;
            return jsx(DragAndDrop, Object.assign({
                id: counterDragAndDrop.next().toString()
            }, {
                children: children
            }), void 0);
        }
    };
    renderers = {
        ...renderers,
        ...customRenderers,
        // @ts-ignore TODO-TS
        imageReference: renderers.image,
        linkReference: renderers.link
    };
    return {
        // We need to allow HTML so that the <cite> tag works properly. Every other
        // HTML tag is filtered by the `allowNode` function.
        allowNode,
        skipHtml: false,
        escapeHtml: false,
        parserOptions: {
            commonmark: true,
            footnotes: true
        },
        plugins: [
            remarkUnwrapImages,
            remarkMath,
            // https://github.com/remarkjs/remark/tree/master/packages/remark-parse#parserinlinemethods
            [
                remarkAttr,
                {
                    elements: [
                        'link',
                        'emphasis'
                    ],
                    extend: {
                        image: [
                            'size'
                        ],
                        emphasis: [
                            'definition'
                        ]
                    }
                }, 
            ],
            remarkMacro.transformer,
            [
                remarkTerms,
                [
                    {
                        name: termsNodeName,
                        open: '{{',
                        close: '}}'
                    }, 
                ], 
            ], 
        ],
        // allows us to find the image node in the `image` renderer
        // https://github.com/arobase-che/remark-attr/issues/16#issuecomment-577487013
        rawSourcePos: true,
        renderers,
        // exposed for unit tests
        [Symbol.for('imageNodes')]: imageNodes,
        [Symbol.for('nodeKey')]: nodeKey
    };
}

export { createRenderers as default };
