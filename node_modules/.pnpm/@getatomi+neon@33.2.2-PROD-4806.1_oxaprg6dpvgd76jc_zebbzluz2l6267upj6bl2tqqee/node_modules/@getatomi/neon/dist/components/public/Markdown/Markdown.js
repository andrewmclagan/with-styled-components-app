import { jsx } from 'react/jsx-runtime';
import cx from 'classnames';
import ReactMarkdown from 'react-markdown';
import { useCallback, useMemo, useEffect } from 'react';
import styled, { ThemeProvider } from 'styled-components';
import { useDroppable } from '@dnd-kit/core';
import ChildrenUtils from 'react-children-utilities';
import 'katex/dist/contrib/mhchem.js';
import { imageSizes as imageSizes$1 } from '../../../constants/sizes.js';
import Box from '../Box/Box.js';
import DraggableAnswer, { variants } from '../../private/DraggableAnswer/DraggableAnswer.js';
import Definition$1 from '../../private/Definition/Definition.js';
import Img from '../../private/Image/Image.js';
import Link$1 from '../../private/Link/Link.js';
import Panel$1 from '../Panel/Panel.js';
import { useDragAndDropQuestionContext } from '../QuizQuestion/DragAndDropQuestionContext.js';
import createRenderers from './createRenderers.js';
import markdownStyles from './Markdown.css.js';

const MarkdownTheme = styled.div`
  --neon-Markdown-bullet-color: ${(props)=>props.color
};
`;
/**
 * @see https://github.com/syntax-tree/mdast
 */ const disallowedTypes = [
    'code',
    'inlineCode'
];
const limitedTypes = [
    'root',
    'paragraph',
    'text',
    'emphasis',
    'strong',
    'blockquote',
    'link',
    'linkReference',
    'list',
    'listItem',
    'image',
    'imageReference',
    'table',
    'tableHead',
    'tableBody',
    'tableRow',
    'tableCell',
    'html', 
];
const allowedHtml = [
    'cite',
    'sub',
    'sup',
    'ul',
    'ol',
    'li',
    'br'
];
const imageSizes = Object.freeze({
    'x-small': imageSizes$1.small1X,
    small: imageSizes$1.small,
    medium: imageSizes$1.root,
    large: imageSizes$1.large
});
const Definition = styled(Definition$1)``;
function DragAndDrop(props) {
    const { children , id  } = props;
    const { assistiveTexts: { blankAssistiveText  } , actions: { addAnswer , addAnswerToBank , moveAnswerToBank  } , answerMaxLength , answerMaxLengthInfo , answers , isCheckingAnswers , isPreviewingAnswers , isSkipped ,  } = useDragAndDropQuestionContext();
    // the dropped answer if any
    const answer = answers.find((a)=>a.droppableId === id
    );
    const isFilled = !!answer;
    const isCorrectAnswer = isFilled && (answer === null || answer === void 0 ? void 0 : answer.draggableId) === id;
    const { isOver , setNodeRef  } = useDroppable({
        id,
        disabled: isFilled
    });
    // get the DraggableAnswer variant and info props
    let draggableAnswerVariant = variants.dropped;
    let draggableAnswerInfo;
    if (isCheckingAnswers) {
        if (isCorrectAnswer) {
            draggableAnswerVariant = variants.correct;
        } else {
            draggableAnswerVariant = variants.incorrect;
            // the answer is incorrect, display the expected answer with the info prop
            draggableAnswerInfo = children;
        }
    }
    if (isPreviewingAnswers && answerMaxLength) {
        if (ChildrenUtils.onlyText(children).length > answerMaxLength) {
            // the answer has two many characters
            draggableAnswerVariant = variants.warning;
            draggableAnswerInfo = answerMaxLengthInfo;
        } else {
            draggableAnswerVariant = variants.correct;
        }
    }
    if (isSkipped) {
        draggableAnswerVariant = variants.skipped;
    }
    const showCorrectAnswers = isPreviewingAnswers || isSkipped;
    // add draggable answer to the DragAndDropQuestion bank using the context
    useEffect(()=>{
        const newAnswer = {
            draggableId: id,
            title: children,
            value: ChildrenUtils.onlyText(children),
            isExtractedFromMarkdown: true
        };
        showCorrectAnswers ? addAnswer({
            ...newAnswer,
            droppableId: id
        }) : addAnswerToBank(newAnswer);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    return jsx(DraggableAnswer.Droppable, Object.assign({
        ref: setNodeRef,
        isOver: isOver,
        isFilled: isFilled,
        isIncorrect: isCheckingAnswers && !isCorrectAnswer || isPreviewingAnswers && !!draggableAnswerInfo,
        assistiveText: !isFilled ? blankAssistiveText : undefined,
        testHook: `markdown-drag-and-drop-droppable-${id}`
    }, {
        children: answer ? jsx(DraggableAnswer, Object.assign({
            variant: draggableAnswerVariant,
            onRemove: isCheckingAnswers || showCorrectAnswers ? undefined : ()=>moveAnswerToBank(answer.draggableId)
            ,
            info: draggableAnswerInfo,
            testHook: `markdown-drag-and-drop-answer-${id}`
        }, {
            children: answer.title
        }), void 0) // display the assistive text (but hidden visually) so that the blank
         : // droppable is aligned correct
        blankAssistiveText
    }), void 0);
}
const Image = Img;
const Link = styled(Link$1)``;
function Panel(param) {
    let { variant , children ,  } = param;
    return jsx(Panel$1, Object.assign({
        className: markdownStyles.panel,
        variant: variant
    }, {
        children: children
    }), void 0);
}
function Markdown(props) {
    const { allowedElements , className , children , customRenderers , isLimited =false , isUnwrapped , as ='div' , aria , linkComponent =null , testHook , vars ,  } = props;
    const removeParagraphFromTypes = useCallback((types)=>{
        return isUnwrapped ? types.filter((type)=>type !== 'paragraph'
        ) : types;
    }, [
        isUnwrapped
    ]);
    const allowedElementRules = isLimited && removeParagraphFromTypes(limitedTypes) || allowedElements;
    // react-markdown runs the parser with all plugins every time it renders,
    // which is expensive and creates new Image elements and thus flickering
    const content = useMemo(()=>// @ts-ignore - TODO-TS[ENHANCEMENT] would require behaviour change
        jsx(ReactMarkdown, Object.assign({}, createRenderers(linkComponent, allowedHtml, customRenderers), allowedElementRules ? {
            allowedTypes: allowedElementRules
        } : {
            disallowedTypes
        }, {
            unwrapDisallowed: isUnwrapped
        }, {
            children: children
        }), void 0)
    , [
        allowedElementRules,
        children,
        customRenderers,
        linkComponent,
        isUnwrapped
    ]);
    return jsx(ThemeProvider, Object.assign({
        theme: {
            isLimited
        }
    }, {
        children: jsx(Box, Object.assign({}, aria, {
            as: as,
            className: cx(markdownStyles.root, className, {
                [markdownStyles.isLimited]: isLimited
            }),
            vars: vars,
            testHook: testHook
        }, {
            children: content
        }), void 0)
    }), void 0);
}

export { Definition, DragAndDrop, Image, Link, MarkdownTheme, Panel, Markdown as default, imageSizes };
