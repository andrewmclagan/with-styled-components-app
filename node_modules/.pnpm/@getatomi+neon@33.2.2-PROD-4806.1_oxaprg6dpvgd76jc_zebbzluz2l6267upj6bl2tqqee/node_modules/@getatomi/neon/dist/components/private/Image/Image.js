import 'core-js/modules/esnext.map.delete-all.js';
import 'core-js/modules/esnext.map.every.js';
import 'core-js/modules/esnext.map.filter.js';
import 'core-js/modules/esnext.map.find.js';
import 'core-js/modules/esnext.map.find-key.js';
import 'core-js/modules/esnext.map.includes.js';
import 'core-js/modules/esnext.map.key-of.js';
import 'core-js/modules/esnext.map.map-keys.js';
import 'core-js/modules/esnext.map.map-values.js';
import 'core-js/modules/esnext.map.merge.js';
import 'core-js/modules/esnext.map.reduce.js';
import 'core-js/modules/esnext.map.some.js';
import 'core-js/modules/esnext.map.update.js';
import 'core-js/modules/web.dom-collections.iterator.js';
import { jsx } from 'react/jsx-runtime';
import { useState, useRef, useCallback, useLayoutEffect } from 'react';
import cx from 'classnames';
import useWindowResize from '../../../utils/useWindowResize.js';
import { imageSizes } from '../../../constants/sizes.js';
import styles from './Image.css.js';

const aspectRatios = {
    [imageSizes.small1X]: 1,
    [imageSizes.small]: 16 / 9,
    [imageSizes.root]: 1,
    [imageSizes.large]: 9 / 16
};
// exported for unit tests
const images = new Map();
function Img(props) {
    const { alt , size =imageSizes.root , src , testHook  } = props;
    const aspectRatio = aspectRatios[size];
    const [dimensions, setDimensions] = useState(()=>{
        const { width =0 , height =0  } = images.get(src) || {};
        return {
            intrinsicWidth: width,
            intrinsicHeight: height,
            width,
            height
        };
    });
    // This hooks returns a counter that increments each time it detects the
    // window is resizing. It has no impact on the DOM (see the useLayoutHook
    // using resized).
    const resized = useWindowResize();
    const ref = useRef(null);
    // This should be called only in `useLayoutEffect` to avoid layout thrashing.
    // - https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing
    // - https://gist.github.com/paulirish/5d52fb081b3570c81e3a
    const getMaxWidth = ()=>ref.current ? Number.parseInt(getComputedStyle(ref.current).width, 10) : 0
    ;
    const updateDimensions = useCallback((param)=>{
        let { maxWidth , ...argDimensions } = param;
        if (!ref.current) return;
        setDimensions((stateDimensions)=>{
            const { intrinsicWidth =stateDimensions.intrinsicWidth , intrinsicHeight =stateDimensions.intrinsicHeight ,  } = argDimensions;
            let width = intrinsicWidth;
            let height = intrinsicHeight;
            if (intrinsicWidth > maxWidth) {
                width = maxWidth;
                const shrinkage = width / intrinsicWidth;
                height = Math.min(maxWidth / aspectRatio, intrinsicHeight * shrinkage);
            }
            return {
                intrinsicWidth,
                intrinsicHeight,
                width,
                height
            };
        });
    }, [
        aspectRatio
    ]);
    // This effect deals with image (pre)loading. Once the image is loaded, it
    // will update the bounding box's dimensions. Technically, it runs whenever
    // the `src` prop changes (new image needs to be (pre)loaded but in most cases
    // it would run on mount only.
    useLayoutEffect(()=>{
        const image = new Image();
        image.onload = ()=>updateDimensions({
                intrinsicWidth: image.width,
                intrinsicHeight: image.height,
                maxWidth: getMaxWidth()
            })
        ;
        image.src = src;
        // save a reference so the image keeps loading after the effect has run
        images.set(src, image);
        return ()=>{
            images.delete(src);
        };
    }, [
        src,
        updateDimensions
    ]);
    // This effect does the work that needs to be done when the page is resized.
    // It synchronously reads the width of the bounding box and updates the height
    // based on aspect ratio and image size.
    useLayoutEffect(()=>{
        updateDimensions({
            maxWidth: getMaxWidth()
        });
    }, [
        resized,
        updateDimensions
    ]);
    return jsx("div", {
        children: jsx("div", Object.assign({
            ref: ref,
            className: cx(styles.root, size === imageSizes.small1X && styles.small1X),
            style: {
                // this variable determines the maximum box dimensions where the image is inscribed
                // https://css-tricks.com/aspect-ratio-boxes/
                '--aspect-ratio': aspectRatio,
                // height is calculated by taking the smallest of:
                // - scaled image height
                // - bounding box height
                height: dimensions.height
            },
            "data-test": testHook
        }, {
            children: jsx("img", {
                alt: alt,
                src: src,
                loading: "lazy"
            }, void 0)
        }), void 0)
    }, void 0);
}

export { Img as default, images };
