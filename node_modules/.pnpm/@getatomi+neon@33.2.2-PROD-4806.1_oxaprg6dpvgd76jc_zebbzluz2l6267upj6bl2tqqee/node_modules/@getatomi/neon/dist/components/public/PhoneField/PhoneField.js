import { jsx } from 'react/jsx-runtime';
import { forwardRef, useRef, useCallback, useEffect } from 'react';
import useMergedRef from '@react-hook/merged-ref';
import intlTelInput from 'intl-tel-input';
import cx from 'classnames';
import TextField from '../TextField/TextField.js';
import styles from './PhoneField.css.js';

const PhoneField = /*#__PURE__*/ forwardRef(function PhoneField(props, ref2) {
    const { initialCountry , isDisabled , localizedCountries , onlyCountries =[] , onChange , preferredCountries =[] , value , ...textFieldProps } = props;
    const textFieldContainerRef = useRef(null);
    const textFieldRef = useRef(null);
    const textFieldMergedRef = useMergedRef(ref2, textFieldRef);
    const itiRef = useRef(null);
    const onChangeHandler = useCallback((e)=>{
        const { current: iti  } = itiRef;
        if (iti) {
            onChange({
                isValid: iti.isValidNumber(),
                number: iti.getNumber(),
                value: e.currentTarget.value
            });
        }
    }, [
        onChange
    ]);
    // initialise the intl-tel-input lib on mount only
    useEffect(()=>{
        var // intl-tel-input exposes a promise for when the utilsScript has completed.
        // Once it has loaded we will trigger one initial onChange so the comsumer
        // can get the current { isValid, number, value } value.
        //
        // This won't overwrite the users input if the util script is slow to load
        // because it is only referencing the value in the actual input and not
        // internal state
        ref3;
        // TODO-TS technically want to avoid ! outside of tests imo. it would require a behaviour change without though, thoughts?
        const iti = intlTelInput(textFieldRef.current, {
            // The utility script is not part of the intl-tel-input lib so that it can
            // be loaded once the consumer page finished loading
            // https://github.com/jackocnr/intl-tel-input#utilities-script
            utilsScript: 'https://cdn.jsdelivr.net/npm/intl-tel-input@17.0.3/build/js/utils.js',
            initialCountry,
            localizedCountries,
            onlyCountries,
            preferredCountries,
            customContainer: cx(styles.root, {
                [styles.isDisabled]: isDisabled
            }),
            separateDialCode: true
        });
        itiRef.current = iti;
        if (value) {
            var ref1;
            (ref1 = itiRef.current) === null || ref1 === void 0 ? void 0 : ref1.setNumber(value);
        }
        (ref3 = itiRef.current) === null || ref3 === void 0 ? void 0 : ref3.promise.then(()=>{
            var ref;
            if ((ref = itiRef.current) === null || ref === void 0 ? void 0 : ref.telInput) {
                onChangeHandler({
                    currentTarget: {
                        value: itiRef.current.telInput.value
                    }
                });
            }
        });
        return ()=>{
            var ref;
            (ref = itiRef.current) === null || ref === void 0 ? void 0 : ref.destroy();
        }; // the configuration props such as initialCountry won't change after the
    // initial mount so we can run that effect on mount only to prevent
    // initialising the plugin multiple times.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    // handle country dropdown listeners:
    // https://github.com/jackocnr/intl-tel-input#events
    useEffect(()=>{
        // The ref value will like have changed by the time the cleanup function
        // runs so it is recommended to save it in scoped variable.
        const input = textFieldRef.current;
        const onCountryChange = (e)=>{
            onChangeHandler(e);
        };
        // sets the width on the dropdown to match the TextField width: this can't
        // be done in CSS because the dropdown isn't a child of the TextField
        const onCountryOpen = ()=>{
            var ref;
            const textFieldWidth = (ref = textFieldContainerRef.current) === null || ref === void 0 ? void 0 : ref.clientWidth;
            const countryList = document.querySelector(`.${styles.root} [role="listbox"]`);
            if (textFieldWidth != null && countryList) {
                countryList.style.minWidth = `${textFieldWidth}px`;
            }
        };
        input === null || input === void 0 ? void 0 : input.addEventListener('countrychange', onCountryChange);
        input === null || input === void 0 ? void 0 : input.addEventListener('open:countrydropdown', onCountryOpen);
        return ()=>{
            input === null || input === void 0 ? void 0 : input.removeEventListener('countrychange', onCountryChange);
            input === null || input === void 0 ? void 0 : input.removeEventListener('open:countrydropdown', onCountryOpen);
        };
    }, [
        onChangeHandler
    ]);
    return jsx(TextField, Object.assign({}, textFieldProps, {
        ref: textFieldMergedRef,
        containerRef: textFieldContainerRef,
        isDisabled: isDisabled,
        type: "tel",
        onChange: onChangeHandler,
        defaultValue: value
    }), void 0);
});

export { PhoneField as default };
