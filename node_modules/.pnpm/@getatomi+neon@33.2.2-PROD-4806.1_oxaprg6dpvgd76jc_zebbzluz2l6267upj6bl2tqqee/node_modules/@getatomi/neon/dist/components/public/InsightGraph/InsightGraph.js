import 'core-js/modules/web.dom-collections.iterator.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useMemo } from 'react';
import { ResponsiveContainer, LineChart, CartesianGrid, Legend, Tooltip, Line, LabelList, XAxis, Text as Text$1, YAxis } from 'recharts';
import cx from 'classnames';
import Text from '../Text/Text.js';
import { useMedia } from '../Media/Media.js';
import { breakpoints } from '../../../constants/tokens/breakpoints.js';
import { colors } from '../../../constants/tokens/colors.js';
import Tooltip$1 from '../Tooltip/Tooltip.js';
import styles from './InsightGraph.css.js';

const breakpoint = {
    minWidth: breakpoints.breakpointSmallFrom
};
const toPair = (group, comparisonFunction)=>// eslint-disable-next-line no-nested-ternary
    group.length === 1 ? comparisonFunction(group[0]) ? [
        group[0],
        null
    ] : [
        null,
        group[0]
    ] : [
        group[0],
        group[1]
    ]
;
function useMinMaxLabelContent(data, minMax, renderValue) {
    return useMemo(()=>{
        // find the indexes of the minimum and/or maximum value in the data
        // TODO-TS: typeguard preferred `!` users before .y - a typeguard would be better
        const [min, max] = data.reduce((param, point, index)=>{
            let [prevMin, prevMax] = param;
            return [
                !data[prevMin] || point && point.y < data[prevMin].y ? index : prevMin,
                !data[prevMax] || point && point.y > data[prevMax].y ? index : prevMax, 
            ];
        }, [
            0,
            0
        ]);
        return function labelContent(param) {
            let { value , index  } = param;
            if (minMax.includes('min') && index === min || minMax.includes('max') && index === max) {
                return renderValue(value);
            }
            return null;
        };
    }, [
        data,
        minMax,
        renderValue
    ]);
}
function CustomTooltip(param) {
    let { active , payload , label , renderTooltipContent  } = param;
    if (!payload || payload.length === 0) return null;
    return jsx(Tooltip$1, Object.assign({
        animation: "fade",
        arrow: false,
        content: renderTooltipContent({
            label,
            payload: toPair(payload, (p)=>{
                return (p === null || p === void 0 ? void 0 : p.dataKey) !== 'y';
            })
        }),
        inertia: false,
        isTextOnly: false,
        placement: "top",
        theme: "light-border",
        triggerTarget: document.querySelector('.recharts-tooltip-cursor'),
        visible: active
    }, {
        children: jsx("span", {
            tabIndex: -1
        }, void 0)
    }), void 0);
}
function InsightGraph(props) {
    const { data: [comparison, current] , isEmbedded , renderValue , renderTooltipContent , testHook , xAxisProps ,  } = props;
    const matches = useMedia(breakpoint);
    const data = current.data.map((point, i)=>{
        var ref, ref1;
        return {
            x: (point === null || point === void 0 ? void 0 : point.x) || ((ref = comparison.data[i]) === null || ref === void 0 ? void 0 : ref.x),
            y: point === null || point === void 0 ? void 0 : point.y,
            yComparison: (ref1 = comparison.data[i]) === null || ref1 === void 0 ? void 0 : ref1.y
        };
    });
    const currentColor = colors.colorAtomiBluesDark;
    const comparisonColor = colors.colorAtomiBluesLighter;
    const currentLabelContent = useMinMaxLabelContent(current.data, 'max', renderValue);
    const comparisonLabelContent = useMinMaxLabelContent(comparison.data, 'min', renderValue);
    const axisProps = {
        axisLine: false,
        interval: 'preserveStartEnd',
        minTickGap: 0,
        tickLine: false
    };
    const lineProps = (color)=>({
            activeDot: {
                stroke: color
            },
            animationDuration: 300,
            connectNulls: true,
            stroke: color,
            strokeWidth: 2,
            type: 'monotone'
        })
    ;
    const dotProps = {
        r: 4
    };
    return jsx("div", Object.assign({
        className: cx(styles.root, isEmbedded && styles.isEmbedded),
        "data-test": testHook
    }, {
        children: jsx(ResponsiveContainer, {
            children: jsxs(LineChart, Object.assign({
                data: data,
                margin: {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }
            }, {
                children: [
                    jsx(CartesianGrid, {
                        stroke: colors.colorFiftyShadesLighter,
                        horizontal: true,
                        vertical: true
                    }, void 0),
                    matches && jsx(Legend, {
                        align: "right",
                        verticalAlign: "top",
                        formatter: (value)=>jsx(Text, Object.assign({
                                as: "span",
                                variant: "bodySmall2X",
                                color: "colorFiftyShadesDarker"
                            }, {
                                children: value
                            }), void 0)
                    }, void 0),
                    matches && jsx(Tooltip, {
                        content: jsx(CustomTooltip, {
                            renderTooltipContent: renderTooltipContent
                        }, void 0),
                        formatter: renderValue,
                        offset: 0,
                        wrapperStyle: {
                            width: 1,
                            height: 1
                        },
                        isAnimationActive: false
                    }, void 0),
                    jsx(Line, Object.assign({}, lineProps(comparisonColor), {
                        dataKey: "yComparison",
                        name: comparison.id,
                        dot: matches && dotProps
                    }, {
                        children: !matches && jsx(LabelList, {
                            content: comparisonLabelContent,
                            fill: colors.colorFiftyShadesDarker,
                            position: "bottom"
                        }, void 0)
                    }), void 0),
                    jsx(Line, Object.assign({}, lineProps(currentColor), {
                        dataKey: "y",
                        name: current.id,
                        dot: matches && dotProps
                    }, {
                        children: !matches && jsx(LabelList, {
                            content: currentLabelContent,
                            fill: currentColor,
                            position: "top"
                        }, void 0)
                    }), void 0),
                    jsx(XAxis, Object.assign({}, axisProps, {
                        interval: !matches ? 0 : axisProps.interval,
                        tick: matches || jsx(Text$1, {}, void 0),
                        mirror: !matches
                    }, matches && xAxisProps, {
                        dataKey: "x"
                    }), void 0),
                    jsx(YAxis, Object.assign({}, axisProps, {
                        tickCount: 5,
                        tickFormatter: (value)=>matches && value ? renderValue(value) : ''
                        ,
                        mirror: true
                    }), void 0)
                ]
            }), void 0)
        }, void 0)
    }), void 0);
}

export { InsightGraph as default };
