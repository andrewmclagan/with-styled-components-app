import 'core-js/modules/web.dom-collections.iterator.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useReducer, useState, useCallback, useMemo, useEffect, useRef, useLayoutEffect } from 'react';
import _ from 'lodash';
import cx from 'classnames';
import { useSensors, useSensor, PointerSensor, TouchSensor, KeyboardSensor, DndContext, DragOverlay, defaultDropAnimation, defaultDropAnimationSideEffects, useDroppable, useDraggable } from '@dnd-kit/core';
import { restrictToWindowEdges } from '@dnd-kit/modifiers';
import ChildrenUtils from 'react-children-utilities';
import DraggableAnswer from '../../private/DraggableAnswer/DraggableAnswer.js';
import Markdown from '../Markdown/Markdown.js';
import markdownStyles from '../Markdown/Markdown.css.js';
import HideVisually from '../HideVisually/HideVisually.js';
import Illustration from '../Illustration/Illustration.js';
import { useMedia } from '../Media/Media.js';
import VerticalSpacing from '../VerticalSpacing/VerticalSpacing.js';
import { breakpoints } from '../../../constants/tokens/breakpoints.js';
import QuizQuestion from './QuizQuestion.js';
import { DragAndDropQuestionContext } from './DragAndDropQuestionContext.js';
import { droppableCoordinateGetter } from './droppableCoordinateGetter.js';
import styles from './DragAndDropQuestion.css.js';

const breakpoint = {
    minWidth: breakpoints.breakpointMediumFrom
};
function AnswerBankDraggableAnswer(props) {
    const { id , isDisabled , testHook  } = props;
    const { attributes , isDragging , listeners , setNodeRef  } = useDraggable({
        id,
        disabled: isDisabled
    });
    return jsxs("div", Object.assign({
        ref: setNodeRef,
        className: styles.answersBankDraggableAnswer,
        "data-test": testHook
    }, attributes, listeners, {
        style: isDragging ? {
            opacity: 0.5
        } : undefined
    }, {
        children: [
            ' ',
            jsx(DraggableAnswer, Object.assign({
                isDisabled: isDisabled
            }, {
                children: props.children
            }), void 0)
        ]
    }), void 0);
}
function AnswerBank(props) {
    const { assistiveText , answers , id , isDisabled , testHook  } = props;
    const bankRef = useRef(null);
    const [bankInitialHeight, setBankInitialHeight] = useState(null);
    const withFixedHeight = useMedia(breakpoint);
    const { setNodeRef  } = useDroppable({
        id
    });
    const answersInBank = answers.filter((param)=>{
        let { droppableId  } = param;
        return droppableId === id;
    });
    useLayoutEffect(()=>{
        if (withFixedHeight) {
            var ref;
            var ref1;
            setBankInitialHeight((ref1 = (ref = bankRef.current) === null || ref === void 0 ? void 0 : ref.offsetHeight) !== null && ref1 !== void 0 ? ref1 : null);
        }
    }, [
        answers,
        withFixedHeight
    ]);
    return jsxs("div", Object.assign({
        ref: bankRef,
        style: {
            minHeight: bankInitialHeight || undefined
        },
        "data-test": testHook
    }, {
        children: [
            jsx(HideVisually, {
                children: assistiveText
            }, void 0),
            jsx("ul", Object.assign({
                ref: setNodeRef,
                className: styles.answersBank
            }, {
                children: answersInBank.map((answer)=>jsx("li", Object.assign({
                        className: styles.answerBankItem
                    }, {
                        children: jsx(AnswerBankDraggableAnswer, Object.assign({
                            id: answer.draggableId,
                            isDisabled: isDisabled,
                            testHook: testHook && `${testHook}-answer`
                        }, {
                            children: answer.title
                        }), void 0)
                    }), answer.draggableId)
                )
            }), void 0)
        ]
    }), void 0);
}
function answersReducer(answers, action) {
    switch(action.type){
        case 'add':
            const newAnswers = [
                ...answers.filter((param)=>{
                    let { draggableId  } = param;
                    return draggableId !== action.answer.draggableId;
                }),
                action.answer, 
            ];
            return action.shuffle ? _.shuffle(newAnswers) : newAnswers;
        case 'drop':
            return answers.map((answer)=>answer.draggableId === action.draggableId ? {
                    ...answer,
                    droppableId: action.droppableId
                } : answer
            );
        /* istanbul ignore next */ default:
            // @ts-ignore - helps us avoid typos!
            throw new Error(`Unhandled action type: ${action.type}`);
    }
}
function DragAndDropQuestion(props) {
    const { answerMaxLength , answerMaxLengthInfo , answersBankId , assistiveTexts: { bankAssistiveText , blankAssistiveText , getCorrectAnswerAssistiveText , getIncorrectAnswerAssistiveText , getOnDragCancelAssistiveText , getOnDragEndAssistiveText , getOnDragOverAssistiveText , getOnDragStartAssistiveText , draggableAssistiveText ,  } , incorrectAnswers , initialAnswers , isCheckingAnswers , isPreviewingAnswers , linkComponent , onAnswersChange , onDragEnd , onDragStart , testHook , title , isSkipped , ...questionProps } = props;
    const [answers, dispatchAnswers] = useReducer(answersReducer, []);
    const [draggedAnswer, setDraggedAnswer] = useState(null);
    const [isInitialAnswersDropped, setIsInitialAnswersDropped] = useState(false);
    const sensors = useSensors(useSensor(PointerSensor), useSensor(TouchSensor), useSensor(KeyboardSensor, {
        coordinateGetter: droppableCoordinateGetter(answersBankId)
    }));
    // reducer helpers
    const addAnswer = (answer)=>dispatchAnswers({
            type: 'add',
            answer,
            shuffle: !isPreviewingAnswers
        })
    ;
    const addAnswerToBank = (answer)=>addAnswer({
            ...answer,
            droppableId: answersBankId
        })
    ;
    const moveAnswer = (param)=>{
        let { draggableId , droppableId ,  } = param;
        return dispatchAnswers({
            type: 'drop',
            draggableId,
            droppableId
        });
    };
    const moveAnswerToBank = (draggableId)=>moveAnswer({
            draggableId,
            droppableId: answersBankId
        })
    ;
    // drag actions
    const onDragStartHandler = (event)=>{
        setDraggedAnswer(_.find(answers, {
            draggableId: event.active.id
        }));
        if (onDragStart) onDragStart();
    };
    const onDragEndHandler = (event)=>{
        const { active , over  } = event;
        if (!over || over.id === answersBankId) {
            return;
        }
        moveAnswer({
            draggableId: active.id,
            droppableId: over.id
        });
        setDraggedAnswer(null);
        if (onDragEnd) onDragEnd();
    };
    const onDragCancelHandler = ()=>{
        if (onDragEnd) onDragEnd();
    };
    const getAnswerTitle = useCallback((id)=>{
        var ref;
        return ChildrenUtils.onlyText((ref = _.find(answers, {
            draggableId: id
        })) === null || ref === void 0 ? void 0 : ref.title);
    }, [
        answers
    ]);
    const countExtractedAnswersFromMarkdown = answers.filter((param)=>{
        let { isExtractedFromMarkdown  } = param;
        return isExtractedFromMarkdown;
    }).length;
    // DndContext draggable screen readers announcements
    // https://docs.dndkit.com/guides/accessibility#screen-reader-announcements-using-live-regions
    const announcements = useMemo(()=>({
            onDragStart: (param)=>{
                let { active  } = param;
                return getOnDragStartAssistiveText(getAnswerTitle(active.id));
            },
            onDragOver: (param)=>{
                let { active , over  } = param;
                if (over) {
                    return getOnDragOverAssistiveText(getAnswerTitle(active.id), over.id, countExtractedAnswersFromMarkdown);
                }
            },
            onDragEnd: (param)=>{
                let { active , over  } = param;
                if (over) {
                    return getOnDragEndAssistiveText(getAnswerTitle(active.id), over.id, countExtractedAnswersFromMarkdown);
                }
            },
            onDragCancel: (param)=>{
                let { active  } = param;
                return getOnDragCancelAssistiveText(getAnswerTitle(active.id));
            }
        })
    , [
        countExtractedAnswersFromMarkdown,
        getAnswerTitle,
        getOnDragStartAssistiveText,
        getOnDragCancelAssistiveText,
        getOnDragOverAssistiveText,
        getOnDragEndAssistiveText, 
    ]);
    // add incorrect answers (the ones not coming from the markdown title) to the
    // bank
    useEffect(()=>{
        if (!incorrectAnswers || incorrectAnswers.length === 0) return;
        incorrectAnswers.map((incorrectAnswer, index)=>addAnswerToBank({
                // using isUnwrapped to remove the wrapping paragraph element
                title: jsx(Markdown, Object.assign({
                    isLimited: true,
                    as: "span",
                    isUnwrapped: true
                }, {
                    children: incorrectAnswer
                }), void 0),
                value: incorrectAnswer,
                draggableId: `incorrect-answer-${index}`,
                isExtractedFromMarkdown: false
            })
        );
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        incorrectAnswers
    ]);
    // let the consumer know when the answers changes (e.g an answer is dropped)
    useEffect(()=>{
        if (onAnswersChange) {
            onAnswersChange(answers);
        }
    }, [
        onAnswersChange,
        answers
    ]);
    const hasInitialAnswers = initialAnswers && initialAnswers.length > 0;
    // if there are initial answers, populate fields where they were dropped
    useEffect(()=>{
        if (!hasInitialAnswers) {
            return;
        }
        if (answers.length > 0 && !isInitialAnswersDropped) {
            initialAnswers.forEach((value, index)=>{
                const answer1 = answers.find((answer)=>answer.value === value
                );
                if (answer1) {
                    moveAnswer({
                        ...answer1,
                        droppableId: (index + 1).toString()
                    });
                }
            });
            setIsInitialAnswersDropped(true);
        }
    }, [
        answers,
        hasInitialAnswers,
        initialAnswers,
        isInitialAnswersDropped
    ]);
    return jsx(DragAndDropQuestionContext.Provider, Object.assign({
        value: {
            answerMaxLength,
            answerMaxLengthInfo,
            answers,
            isCheckingAnswers,
            isPreviewingAnswers,
            isSkipped,
            actions: {
                addAnswer,
                addAnswerToBank,
                moveAnswerToBank
            },
            assistiveTexts: {
                blankAssistiveText
            }
        }
    }, {
        children: jsxs(DndContext, Object.assign({
            sensors: sensors,
            onDragStart: onDragStartHandler,
            onDragEnd: onDragEndHandler,
            onDragCancel: onDragCancelHandler,
            accessibility: {
                announcements,
                screenReaderInstructions: {
                    draggable: draggableAssistiveText
                }
            }
        }, {
            children: [
                jsx("div", Object.assign({
                    role: "status",
                    "data-test": testHook && `${testHook}-validation-messages`
                }, {
                    children: isCheckingAnswers && jsx(HideVisually, {
                        children: jsx("ul", {
                            children: answers.filter((param)=>{
                                let { droppableId  } = param;
                                return droppableId !== answersBankId;
                            }).sort((a, b)=>+a.droppableId - +b.droppableId
                            ).map((answer)=>jsx("li", {
                                    children: answer.droppableId === answer.draggableId ? getCorrectAnswerAssistiveText(ChildrenUtils.onlyText(answer.title)) : getIncorrectAnswerAssistiveText(ChildrenUtils.onlyText(answer.title), getAnswerTitle(answer.droppableId))
                                }, answer.draggableId)
                            )
                        }, void 0)
                    }, void 0)
                }), void 0),
                jsx(VerticalSpacing, Object.assign({
                    size: "large1X"
                }, {
                    children: jsx(Illustration, {
                        name: "main-dnd",
                        size: "small"
                    }, void 0)
                }), void 0),
                jsx(VerticalSpacing, Object.assign({
                    size: "small"
                }, {
                    children: jsx(AnswerBank, {
                        assistiveText: bankAssistiveText,
                        id: answersBankId,
                        answers: answers,
                        testHook: testHook && `${testHook}-bank`,
                        isDisabled: isCheckingAnswers || isSkipped
                    }, void 0)
                }), void 0),
                jsx(QuizQuestion, Object.assign({}, questionProps, {
                    title: jsx(Markdown, Object.assign({
                        className: cx(markdownStyles.question, markdownStyles.dragAndDrop),
                        linkComponent: linkComponent,
                        isLimited: true
                    }, {
                        children: title
                    }), void 0),
                    testHook: testHook,
                    variant: isSkipped ? 'skipped' : undefined
                }), void 0),
                jsx(DragOverlay, Object.assign({
                    modifiers: [
                        restrictToWindowEdges
                    ],
                    dropAnimation: {
                        ...defaultDropAnimation,
                        sideEffects: defaultDropAnimationSideEffects({
                            styles: {
                                active: {
                                    opacity: '0.5'
                                }
                            }
                        })
                    }
                }, {
                    children: draggedAnswer ? jsx(DraggableAnswer, Object.assign({
                        isDragged: true
                    }, {
                        children: draggedAnswer.title
                    }), void 0) : null
                }), void 0)
            ]
        }), void 0)
    }), void 0);
}

export { DragAndDropQuestion as default };
