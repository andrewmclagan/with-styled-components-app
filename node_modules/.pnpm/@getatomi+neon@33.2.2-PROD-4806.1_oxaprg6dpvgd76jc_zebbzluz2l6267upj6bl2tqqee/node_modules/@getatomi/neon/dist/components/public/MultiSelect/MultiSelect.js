import 'core-js/modules/web.dom-collections.iterator.js';
import { jsxs, jsx, Fragment } from 'react/jsx-runtime';
import { useRef, useReducer, useMemo, createRef, useCallback, useEffect, cloneElement } from 'react';
import Popover from '@reach/popover';
import cx from 'classnames';
import _ from 'lodash';
import { FixedSizeList } from 'react-window';
import AutoSizer from 'react-virtualized-auto-sizer';
import { breakpoints } from '../../../constants/tokens/breakpoints.js';
import Button from '../Button/Button.js';
import Box from '../Box/Box.js';
import Checkbox from '../Checkbox/Checkbox.js';
import MenuItem from '../MenuItem/MenuItem.js';
import Drawer from '../Drawer/Drawer.js';
import { useMedia } from '../Media/Media.js';
import SelectTrigger from '../SelectTrigger/SelectTrigger.js';
import SearchInput from '../../private/SearchInput/SearchInput.js';
import useLatch from '../../../utils/useLatch.js';
import styles from './MultiSelect.css.js';

const focus = (ref)=>{
    var ref1;
    return (ref1 = ref.current) === null || ref1 === void 0 ? void 0 : ref1.focus();
};
function reducer(state, action) {
    switch(action.type){
        case 'openPopover':
            return {
                ...state,
                popoverIsOpen: true
            };
        case 'openDrawer':
            return {
                ...state,
                drawerIsOpen: true
            };
        case 'close':
            return {
                ...state,
                popoverIsOpen: false,
                drawerIsOpen: false
            };
        case 'change':
            {
                const { option , value  } = action;
                // make a copy to avoid in-place mutations
                const newOptions = state.options.slice();
                // `splice` returns the items that were replaced, not the new array.
                // It also mutates the array.
                newOptions.splice(newOptions.indexOf(option), 1, {
                    ...option,
                    checked: value
                });
                return {
                    ...state,
                    options: newOptions
                };
            }
        case 'changeAll':
            {
                const { value  } = action;
                return {
                    ...state,
                    options: state.options.map((option)=>({
                            ...option,
                            checked: value
                        })
                    )
                };
            }
        case 'search':
            {
                const { value  } = action;
                return {
                    ...state,
                    searchQuery: value
                };
            }
        /* istanbul ignore next */ default:
            return state;
    }
}
function MultiSelect(props) {
    const { ariaLabel , id , isDisabled , trigger , doneLabel , checkAllLabel , searchEmptyState , searchPlaceholder , uncheckAllLabel , options =[] , onChange , onClose , drawerProps , popoverPosition , testHook ,  } = props;
    const triggerRef = useRef(null);
    const popoverRef = useRef(null);
    const checkAllRef = useRef(null);
    // TS: We technically shouldn't need to define the useReducer<T, I>, but the
    // way its overloaded it defaults to a DispatchWithoutAction
    const [{ popoverIsOpen , drawerIsOpen , searchQuery , options: stateOptions  }, dispatch] = useReducer(reducer, undefined, ()=>({
            popoverIsOpen: false,
            drawerIsOpen: false,
            searchQuery: '',
            options
        })
    );
    const matches = useMedia({
        minWidth: breakpoints.breakpointMediumFrom
    });
    const selectedOptions = useMemo(()=>stateOptions.filter((option)=>option.checked
        )
    , [
        stateOptions
    ]);
    const searchResults = stateOptions.filter((option)=>option.value.toLowerCase().includes(searchQuery.toLowerCase())
    );
    const hasSearchResults = searchResults.length > 0;
    const checkAllChecked = hasSearchResults && searchResults.every((option)=>option.checked
    );
    const checkboxRefs = searchResults.map(()=>/*#__PURE__*/ createRef()
    );
    const triggerOnChange = useCallback(()=>{
        onChange(selectedOptions);
    }, [
        onChange,
        selectedOptions
    ]);
    const close = useCallback(()=>{
        dispatch({
            type: 'close'
        });
        onClose === null || onClose === void 0 ? void 0 : onClose(selectedOptions); // eslint-disable-line no-unused-expressions
        focus(triggerRef);
    }, [
        onClose,
        selectedOptions
    ]);
    const closeAndCommit = useCallback(()=>{
        triggerOnChange();
        close();
    }, [
        close,
        triggerOnChange
    ]);
    const searchFor = (value)=>dispatch({
            type: 'search',
            value
        })
    ;
    const clearSearchOnClick = ()=>{
        searchFor('');
    };
    const checkAllOnChange = (value)=>dispatch({
            type: 'changeAll',
            value
        })
    ;
    const popoverOnKeyDown = (event)=>{
        if (event.key === 'Escape') {
            // prevent event from bubbling up e.g. when used in a modal
            event.stopPropagation();
            close();
        }
    };
    useLatch({
        // trigger when either the popover or the drawer is open
        value: drawerIsOpen !== popoverIsOpen,
        onChange (value) {
            if (value) {
                // We use `setImmediate` to steal focus from @reach/popover which
                // focuses on the first focusable descendant which is the close button.
                setTimeout(()=>{
                    // Focus the "check all" checkbox if checked
                    // - else the first option if checked
                    // - else the "check all" checkbox, if none are checked
                    // https://www.w3.org/TR/wai-aria-practices-1.2/#listbox_kbd_interaction
                    // Looking at the DOM input state would certainly be easier, but is
                    // not The React Way. There should be only one source of truth whcih
                    // is why we need to do this complicated dance to get the information
                    // from state. And it makes automated testing harder.
                    if (checkAllChecked) return focus(checkAllRef);
                    const firstCheckedIndex = _.findIndex(searchResults, (option)=>!!option.checked
                    );
                    if (firstCheckedIndex >= 0) return focus(checkboxRefs[firstCheckedIndex]);
                    focus(checkAllRef);
                }, 0);
            }
        }
    });
    useEffect(()=>{
        if (popoverIsOpen) {
            triggerOnChange();
        }
    }, [
        popoverIsOpen,
        triggerOnChange,
        stateOptions
    ]);
    useEffect(()=>{
        const listener = (event)=>{
            var ref;
            const { relatedTarget , target  } = event;
            if (popoverIsOpen && !((ref = popoverRef.current) === null || ref === void 0 ? void 0 : ref.contains(relatedTarget || target))) {
                close();
            }
        };
        window.addEventListener('mousedown', listener);
        return ()=>{
            window.removeEventListener('mousedown', listener);
        };
    }, [
        close,
        popoverIsOpen
    ]);
    const checkAll = jsxs("label", Object.assign({
        className: styles.item
    }, {
        children: [
            jsx(Checkbox, {
                ref: checkAllRef,
                size: "small",
                checked: checkAllChecked,
                onChange: checkAllOnChange,
                isDisabled: !hasSearchResults,
                testHook: testHook && `${testHook}-check-all`
            }, void 0),
            checkAllLabel
        ]
    }), void 0);
    const done = jsxs("div", Object.assign({
        className: styles.done
    }, {
        children: [
            jsx(Drawer.CloseButton, {
                onClick: close,
                testHook: testHook && `${testHook}-close`
            }, void 0),
            jsx("div", {
                className: styles.spacer
            }, void 0),
            jsx(Button, Object.assign({
                variant: "link",
                onClick: closeAndCommit,
                testHook: testHook && `${testHook}-done`,
                isDisabled: !hasSearchResults
            }, {
                children: doneLabel
            }), void 0)
        ]
    }), void 0);
    const search = jsx(Box, Object.assign({
        className: styles.search
    }, {
        children: jsx(SearchInput, {
            onChange: (e)=>{
                return searchFor(e === null || e === void 0 ? void 0 : e.target.value);
            },
            onReset: clearSearchOnClick,
            placeholder: searchPlaceholder,
            value: searchQuery,
            testHook: testHook
        }, void 0)
    }), void 0);
    const uncheckAll = jsx("div", Object.assign({
        className: styles.uncheckAll
    }, {
        children: jsx(Button, Object.assign({
            variant: "link",
            onClick: ()=>dispatch({
                    type: 'changeAll',
                    value: false
                })
            ,
            isDisabled: !hasSearchResults,
            testHook: testHook && `${testHook}-uncheck-all`
        }, {
            children: uncheckAllLabel
        }), void 0)
    }), void 0);
    const checkboxItems = searchResults.map((option, i)=>jsxs("label", Object.assign({
            className: styles.item
        }, {
            children: [
                jsx(Checkbox, Object.assign({}, option, {
                    ref: checkboxRefs[i],
                    label: undefined,
                    size: "small",
                    onChange: (value)=>dispatch({
                            type: 'change',
                            option,
                            value
                        })
                    ,
                    testHook: testHook && `${testHook}-item-${i}`
                }), void 0),
                option.label
            ]
        }), void 0)
    );
    const emptyState = jsx("div", Object.assign({
        className: cx(styles.item, styles.emptyState)
    }, {
        children: searchEmptyState
    }), void 0);
    function Items(itemsProps) {
        const { children  } = itemsProps;
        return jsx("div", Object.assign({
            className: styles.items
        }, {
            children: jsx(AutoSizer, {
                children: (param1)=>{
                    let { height , width  } = param1;
                    return jsx(FixedSizeList, Object.assign({
                        innerElementType: "ul",
                        height: height,
                        itemCount: checkboxItems.length,
                        itemSize: 48,
                        width: width
                    }, {
                        children: (param)=>{
                            let { index , style  } = param;
                            return children({
                                index,
                                style: style
                            });
                        }
                    }), void 0);
                }
            }, void 0)
        }), void 0);
    }
    return jsxs(Fragment, {
        children: [
            jsx("button", Object.assign({
                ref: triggerRef,
                id: id,
                disabled: isDisabled,
                "aria-label": ariaLabel,
                type: "button",
                onClick: ()=>dispatch({
                        type: matches ? 'openPopover' : 'openDrawer'
                    })
                ,
                "data-test": testHook && `${testHook}-trigger`
            }, {
                children: /*#__PURE__*/ cloneElement(trigger, {
                    isDisabled
                })
            }), void 0),
            popoverIsOpen && jsxs(Popover, Object.assign({
                ref: popoverRef,
                className: styles.menu,
                targetRef: triggerRef,
                // @ts-ignore TODO-TS[ENHANCEMENT] correct types
                onKeyDown: popoverOnKeyDown,
                position: popoverPosition,
                "data-test": testHook && `${testHook}-popover`
            }, {
                children: [
                    checkAll,
                    search,
                    hasSearchResults ? jsx(Items, {
                        children: (param)=>{
                            let { index , style  } = param;
                            return jsx("li", Object.assign({
                                style: style
                            }, {
                                children: jsx(MenuItem, {
                                    children: checkboxItems[index]
                                }, void 0)
                            }), void 0);
                        }
                    }, void 0) : emptyState,
                    jsx("div", Object.assign({
                        className: styles.menuFooter
                    }, {
                        children: uncheckAll
                    }), void 0)
                ]
            }), void 0),
            drawerIsOpen && jsxs(Drawer, Object.assign({}, drawerProps, {
                ariaLabel: ariaLabel,
                isOpen: true,
                onClose: close,
                testHook: testHook && `${testHook}-drawer`,
                variant: "noMaxHeight"
            }, {
                children: [
                    jsx(Drawer.Header, {
                        children: jsx("div", Object.assign({
                            className: styles.drawerHeader
                        }, {
                            children: done
                        }), void 0)
                    }, void 0),
                    jsxs(Drawer.Content, Object.assign({
                        withPadding: false
                    }, {
                        children: [
                            jsx(Drawer.Item, {
                                children: checkAll
                            }, void 0),
                            jsx(Drawer.Item, Object.assign({
                                fadedOut: true
                            }, {
                                children: search
                            }), void 0),
                            hasSearchResults ? jsx(Items, {
                                children: (param)=>{
                                    let { index , style  } = param;
                                    return jsx(Drawer.Item, Object.assign({
                                        style: style
                                    }, {
                                        children: checkboxItems[index]
                                    }), searchResults[index].value);
                                }
                            }, void 0) : emptyState
                        ]
                    }), void 0),
                    jsx(Drawer.Footer, {
                        children: jsx(Drawer.Item, {
                            children: jsx("div", Object.assign({
                                className: styles.drawerFooter
                            }, {
                                children: uncheckAll
                            }), void 0)
                        }, void 0)
                    }, void 0)
                ]
            }), void 0)
        ]
    }, void 0);
}
MultiSelect.Trigger = SelectTrigger;

export { MultiSelect as default };
