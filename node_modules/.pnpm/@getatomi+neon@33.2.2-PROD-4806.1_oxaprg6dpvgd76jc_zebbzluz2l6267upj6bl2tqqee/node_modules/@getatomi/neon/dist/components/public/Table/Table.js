import 'core-js/modules/web.dom-collections.iterator.js';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { useState, useMemo, useEffect } from 'react';
import { useReactTable, getCoreRowModel, getSortedRowModel, flexRender, createColumnHelper } from '@tanstack/react-table';
import cx from 'classnames';
import Container from '../Container/Container.js';
import HideVisually from '../HideVisually/HideVisually.js';
import Icon from '../Icon/Icon.js';
import Pagination, { pageSizes } from '../../private/Pagination/Pagination.js';
import VerticalSpacing from '../VerticalSpacing/VerticalSpacing.js';
import styles from './Table.css.js';

const INDEX_COLUMN_ID = 'index';
// Create a Table component that is a wrapper around the react-table component
function Table(props) {
    const { children , columns , fetchData , indexAssistiveText , initialState: { pageIndex: initialPageIndex = 0 , pageSize: initialPageSize = pageSizes[0] , sortBy: initialSortBy = [] ,  } = {} , isFixedLayout , isLoading , isSortable =false , isStickyHeadings , pageCount: controlledPageCount = 1 , paginationLabels , renderIndex , renderPageLabel , renderPageSize , scrollPosition , sortingAssistiveText , testHook , toggleSortBy , ...tableOptions } = props;
    const [sorting, setSorting] = useState(initialSortBy);
    const [{ pageIndex: pageIndex1 , pageSize: pageSize1  }, setPagination] = useState({
        pageIndex: initialPageIndex,
        pageSize: initialPageSize
    });
    const pagination = useMemo(()=>({
            pageIndex: pageIndex1,
            pageSize: pageSize1
        })
    , [
        pageIndex1,
        pageSize1
    ]);
    const indexColumnRenderer = (info)=>{
        const { pageIndex , pageSize  } = info.table.getState().pagination;
        return renderIndex && renderIndex(info.row.index + 1 + pageIndex * pageSize);
    };
    const columnsWithIndex = [
        {
            id: INDEX_COLUMN_ID,
            header: ()=>jsx(HideVisually, {
                    children: indexAssistiveText
                }, void 0)
            ,
            cell: indexColumnRenderer,
            meta: {
                loader: indexColumnRenderer,
                style: {
                    width: 1
                }
            },
            enableSorting: false
        },
        ...columns, 
    ];
    const table = useReactTable({
        ...tableOptions,
        columns: renderIndex && indexAssistiveText ? columnsWithIndex : columns,
        enableSorting: isSortable,
        getCoreRowModel: getCoreRowModel(),
        getSortedRowModel: getSortedRowModel(),
        manualSorting: isSortable,
        state: {
            sorting,
            pagination
        },
        onSortingChange: setSorting,
        manualPagination: true,
        onPaginationChange: setPagination,
        pageCount: controlledPageCount
    });
    const hasPagination = !!fetchData && !!renderPageSize;
    const pageSizeOnChange = (newPageSize)=>{
        // normally react-table would do this for us by default but the behaviour is
        // different for manual pagination
        table.setPageIndex(0);
        if (newPageSize) {
            table.setPageSize(newPageSize);
        }
    };
    // manual sorting/pagination are achieved via effects, as per this example
    // https://github.com/tannerlinsley/react-table/blob/master/examples/pagination-controlled/src/App.js#L83-L87
    useEffect(()=>{
        if (toggleSortBy) {
            table.setPageIndex(0);
            toggleSortBy(sorting);
        }
    }, [
        sorting,
        toggleSortBy,
        table
    ]);
    useEffect(()=>{
        if (fetchData) fetchData({
            pageIndex: pageIndex1,
            pageSize: pageSize1
        });
    }, [
        fetchData,
        pageIndex1,
        pageSize1
    ]);
    return jsxs(Fragment, {
        children: [
            jsxs("table", Object.assign({
                className: cx(styles.table, {
                    [styles.isFixedLayout]: isFixedLayout,
                    [styles.isStickyHeadings]: isStickyHeadings,
                    [styles.isScrollingVertically]: scrollPosition && scrollPosition.top > 0,
                    [styles.isScrollingHorizontally]: scrollPosition && scrollPosition.left > 0
                }),
                "data-test": testHook
            }, {
                children: [
                    children,
                    jsx("thead", Object.assign({
                        className: styles.heading
                    }, {
                        children: table.getHeaderGroups().map((headerGroup)=>{
                            return jsx("tr", Object.assign({
                                className: styles.row
                            }, {
                                children: headerGroup.headers.map((header)=>{
                                    var ref, ref1, ref2, ref3;
                                    return jsx("th", Object.assign({
                                        className: cx(styles.cell, {
                                            [styles.isSticky]: isStickyHeadings && ((ref = header.column.columnDef.meta) === null || ref === void 0 ? void 0 : ref.isHeading),
                                            [styles.isCenterAligned]: (ref1 = header.column.columnDef.meta) === null || ref1 === void 0 ? void 0 : ref1.isCenterAligned,
                                            [styles.isEndAligned]: (ref2 = header.column.columnDef.meta) === null || ref2 === void 0 ? void 0 : ref2.isEndAligned
                                        }),
                                        colSpan: header.colSpan,
                                        style: (ref3 = header.column.columnDef.meta) === null || ref3 === void 0 ? void 0 : ref3.style,
                                        scope: "col",
                                        "data-test": testHook && `${testHook}-column-${header.id}`
                                    }, {
                                        children: header.column.getCanSort() ? jsxs("button", Object.assign({
                                            type: "button",
                                            className: cx(styles.sortButton, {
                                                [styles.isSortedDesc]: header.column.getIsSorted() === 'desc'
                                            }),
                                            onClick: header.column.getToggleSortingHandler()
                                        }, {
                                            children: [
                                                sortingAssistiveText && jsx(HideVisually, {
                                                    children: sortingAssistiveText
                                                }, void 0),
                                                ' ',
                                                flexRender(header.column.columnDef.header, header.getContext()),
                                                jsx(Icon, {
                                                    className: cx(styles.chevron, !header.column.getIsSorted() && styles.isVisuallyHidden),
                                                    name: "chevron",
                                                    display: "inline-block",
                                                    size: "sizeIconSmall3X"
                                                }, void 0)
                                            ]
                                        }), void 0) : jsx(Fragment, {
                                            children: flexRender(header.column.columnDef.header, header.getContext())
                                        }, void 0)
                                    }), header.id);
                                })
                            }), headerGroup.id);
                        })
                    }), void 0),
                    jsx("tbody", Object.assign({
                        className: styles.body
                    }, {
                        children: table.getRowModel().rows.map((row)=>{
                            return jsx("tr", Object.assign({
                                className: cx(styles.row, {
                                    [styles.isInactive]: row.original.isInactive,
                                    [styles.isSelected]: row.original.isSelected
                                }),
                                "data-test": testHook ? `${testHook}-row${row.original.isInactive ? '-pending' : ''}` : undefined
                            }, {
                                children: row.getVisibleCells().map((cell)=>{
                                    var ref, ref4, ref5, ref6, ref7, ref8, ref9, ref10;
                                    const CellElement = ((ref = cell.column.columnDef.meta) === null || ref === void 0 ? void 0 : ref.isHeading) ? 'th' : 'td';
                                    return jsx(CellElement, Object.assign({
                                        scope: ((ref4 = cell.column.columnDef.meta) === null || ref4 === void 0 ? void 0 : ref4.isHeading) ? 'row' : undefined,
                                        className: cx(styles.cell, {
                                            [styles.isIndex]: cell.column.id === INDEX_COLUMN_ID,
                                            [styles.isSticky]: isStickyHeadings && ((ref5 = cell.column.columnDef.meta) === null || ref5 === void 0 ? void 0 : ref5.isHeading),
                                            [styles.isCenterAligned]: (ref6 = cell.column.columnDef.meta) === null || ref6 === void 0 ? void 0 : ref6.isCenterAligned,
                                            [styles.isEndAligned]: (ref7 = cell.column.columnDef.meta) === null || ref7 === void 0 ? void 0 : ref7.isEndAligned
                                        }),
                                        style: (ref8 = cell.column.columnDef.meta) === null || ref8 === void 0 ? void 0 : ref8.style
                                    }, {
                                        children: flexRender(isLoading && ((ref9 = cell.column.columnDef.meta) === null || ref9 === void 0 ? void 0 : ref9.loader) ? (ref10 = cell.column.columnDef.meta) === null || ref10 === void 0 ? void 0 : ref10.loader : cell.column.columnDef.cell, cell.getContext())
                                    }), cell.id);
                                })
                            }), row.id);
                        })
                    }), void 0)
                ]
            }), void 0),
            hasPagination && paginationLabels && renderPageSize && renderPageLabel && jsx(VerticalSpacing, Object.assign({
                size: "large1X",
                isUpwards: true
            }, {
                children: jsx(Container, Object.assign({
                    paddingInline: {
                        base: 'spacingRoot',
                        tablet: 'spacingNone'
                    }
                }, {
                    children: jsx(Pagination, {
                        ariaLabel: "Table pagination",
                        pages: table.getPageOptions().map((index)=>index + 1
                        ),
                        currentPage: pageIndex1 + 1,
                        gotoPage: (index)=>table.setPageIndex(index - 1)
                        ,
                        pageSize: pageSize1,
                        renderPageSize: renderPageSize,
                        pageSizeOnChange: pageSizeOnChange,
                        labels: paginationLabels,
                        renderPageLabel: renderPageLabel,
                        testHook: testHook && `${testHook}-pagination`
                    }, void 0)
                }), void 0)
            }), void 0)
        ]
    }, void 0);
}
Table.createColumnHelper = createColumnHelper;

export { Table as default };
