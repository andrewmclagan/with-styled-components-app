import 'core-js/modules/web.dom-collections.iterator.js';
import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { useState, useEffect, cloneElement, useRef } from 'react';
import { Combobox, ComboboxInput, ComboboxPopover, ComboboxList, ComboboxOption } from '@reach/combobox';
import { DialogOverlay, DialogContent } from '@reach/dialog';
import { connectAutoComplete, InstantSearch, Configure, Snippet } from 'react-instantsearch-dom';
import _ from 'lodash';
import cx from 'classnames';
import Box from '../Box/Box.js';
import Container from '../Container/Container.js';
import Icon from '../Icon/Icon.js';
import Truncate from '../Truncate/Truncate.js';
import EmptyState from '../EmptyState/EmptyState.js';
import Illustration from '../Illustration/Illustration.js';
import Tag from '../Tag/Tag.js';
import Text from '../Text/Text.js';
import useId from '../../../utils/useId.js';
import useScroll from '../../../utils/useScroll.js';
import useSyncScrolling from '../../../utils/useSyncScrolling.js';
import styles from './Search.css.js';

const matchLevels = {
    full: 2,
    partial: 1,
    none: 0
};
function Trigger(param) {
    let { placeholder , value , onClick , onReset , resetAssistiveText , testHook ,  } = param;
    return jsxs("div", Object.assign({
        className: styles.triggerWrapper
    }, {
        children: [
            jsxs("button", Object.assign({
                type: "button",
                className: styles.trigger,
                onClick: onClick,
                "data-test": testHook
            }, {
                children: [
                    jsx(Icon, {
                        name: "search",
                        size: "sizeIconSmall2X",
                        color: "colorFiftyShadesDark"
                    }, void 0),
                    jsx(Truncate, Object.assign({
                        color: !value ? 'colorFiftyShadesDarker' : undefined,
                        marginLeft: "spacingSmall",
                        textAlign: "left"
                    }, {
                        children: value || placeholder
                    }), void 0)
                ]
            }), void 0),
            value && // TODO: refactor to use shared discard button.
            jsx("button", Object.assign({
                type: "button",
                className: styles.triggerReset,
                "aria-label": resetAssistiveText,
                onClick: onReset,
                "data-test": testHook && `${testHook}-reset`
            }, {
                children: jsx(Icon, {
                    name: "close",
                    size: "sizeIconSmall2X",
                    color: "colorFiftyShadesDark"
                }, void 0)
            }), void 0)
        ]
    }), void 0);
}
function Dialog(param) {
    let { isOpen , onClose , children , testHook ,  } = param;
    return jsx(DialogOverlay, Object.assign({
        className: styles.overlay,
        isOpen: isOpen,
        onDismiss: ()=>onClose()
        ,
        "data-test": testHook && `${testHook}-overlay`
    }, {
        children: jsx(DialogContent, Object.assign({
            className: styles.content,
            "aria-label": "Search"
        }, {
            children: jsx(Container, Object.assign({
                maxWidth: {
                    base: 'sizeFull',
                    tablet: 'sizeRoot'
                },
                paddingInline: {
                    base: 'spacingNone',
                    tablet: 'spacingLarge3X'
                }
            }, {
                children: jsx("div", Object.assign({
                    "data-test": testHook && `${testHook}-root`,
                    className: styles.root
                }, {
                    children: children
                }), void 0)
            }), void 0)
        }), void 0)
    }), void 0);
}
function Autocomplete(param) {
    let { hits , refine , query , setQuery , minQueryLength =3 , placeholder , closeAssistiveText , resetAssistiveText , emptyStateDescription , renderNoResultsHeading , noResultsDescription , renderOption , footer , isLocked , renderType , onClose , onSelect , testHook ,  } = param;
    const inputRef = useRef(null);
    const footerId = useId('AutoComplete');
    const [{ isScrollable , isEnd  }, scrollProps] = useScroll();
    // TODO-TS there needs to be a small behaviour change between useScroll and
    // useSyncScrolling - null/undefined. misused of ! against scroll.ref
    const inputProps = useSyncScrolling(scrollProps.ref, '[data-highlighted]');
    const hasQuery = query.trim().length >= minQueryLength;
    const hasResults = hasQuery && hits.length > 0;
    useEffect(()=>{
        if (hasQuery) refine(query);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    // eslint-disable-line react-hooks/exhaustive-deps
    const onChange = (event)=>{
        const { value  } = event.currentTarget;
        // ignore empty query (only spaces)
        const valueToSet = value.trim() === '' ? value.trim() : value;
        setQuery(valueToSet);
        refine(valueToSet);
    };
    const onBlur = (event)=>event.preventDefault()
    ;
    const onReset = ()=>{
        var // eslint-disable-next-line no-unused-expressions
        ref;
        setQuery('');
        (ref = inputRef.current) === null || ref === void 0 ? void 0 : ref.focus();
    };
    const handleClose = ()=>onClose(query)
    ;
    const handleSelect = (objectID)=>{
        onSelect(_.find(hits, {
            objectID
        }));
        handleClose();
    };
    return jsxs(Combobox, Object.assign({
        onSelect: handleSelect,
        openOnFocus: hasQuery
    }, {
        children: [
            jsxs("div", Object.assign({
                className: styles.header
            }, {
                children: [
                    jsx(Icon, {
                        name: "search",
                        size: "sizeIconSmall1X",
                        color: "colorFiftyShadesDark"
                    }, void 0),
                    jsx(ComboboxInput, Object.assign({
                        ref: inputRef,
                        className: styles.input,
                        "aria-label": placeholder,
                        placeholder: placeholder,
                        autocomplete: false,
                        autoComplete: "off" // eslint-disable-line react/jsx-no-duplicate-props
                        ,
                        spellCheck: false,
                        autoCorrect: "off",
                        value: query,
                        onChange: onChange,
                        onBlur: onBlur
                    }, inputProps), void 0),
                    hasQuery && jsx("button", Object.assign({
                        type: "button",
                        className: styles.reset,
                        onClick: onReset,
                        "data-test": testHook && `${testHook}-reset`
                    }, {
                        children: resetAssistiveText
                    }), void 0),
                    jsx(Box, Object.assign({
                        as: "button",
                        type: "button",
                        onClick: handleClose,
                        color: "colorFiftyShadesDark",
                        _hoverAndFocus: {
                            color: 'colorCoreText'
                        },
                        transition: "transitionRoot",
                        testHook: testHook && `${testHook}-close`
                    }, {
                        children: jsx(Icon, {
                            name: "close",
                            size: "sizeIconSmall2X",
                            isDecorative: false,
                            title: closeAssistiveText
                        }, void 0)
                    }), void 0)
                ]
            }), void 0),
            jsxs("div", Object.assign({
                className: cx(styles.results, {
                    [styles.withScrollFade]: hasResults && isScrollable && !isEnd
                })
            }, {
                children: [
                    !hasQuery && jsx(Container, Object.assign({
                        maxWidth: {
                            tablet: 'sizeSmall1X'
                        }
                    }, {
                        children: jsx(EmptyState, {
                            header: jsx(Illustration, {
                                name: "emptystate-search",
                                size: "small"
                            }, void 0),
                            description: emptyStateDescription
                        }, void 0)
                    }), void 0),
                    hasQuery && !hasResults && jsx(EmptyState, {
                        headingProps: {
                            children: renderNoResultsHeading(query)
                        },
                        description: noResultsDescription
                    }, void 0),
                    hasResults && // @ts-ignore TODO-TS[ENHANCEMENT] improved types
                    jsx(ComboboxPopover, Object.assign({
                        className: styles.popover,
                        portal: false
                    }, scrollProps, {
                        children: jsx(ComboboxList, Object.assign({
                            "aria-labelledby": footerId
                        }, {
                            children: hits.map((hit, i)=>{
                                const snippetProps = {
                                    tagName: 'mark',
                                    hit
                                };
                                let mainAttribute = hit.captions ? 'captions' : 'description';
                                if (hit._snippetResult.description && hit._snippetResult.captions) {
                                    mainAttribute = matchLevels[hit._snippetResult.captions.matchLevel] >= matchLevels[hit._snippetResult.description.matchLevel] ? 'captions' : 'description';
                                }
                                return jsx(ComboboxOption, Object.assign({
                                    className: styles.result,
                                    value: hit.objectID,
                                    "data-test": testHook && `${testHook}-item-${i}`
                                }, {
                                    children: renderOption(hit, jsxs(Fragment, {
                                        children: [
                                            jsxs("div", Object.assign({
                                                className: styles.titleContainer
                                            }, {
                                                children: [
                                                    isLocked(hit.access_level) && jsx(Icon, {
                                                        name: "lock",
                                                        size: "sizeIconSmall",
                                                        color: "colorFiftyShadesLight",
                                                        testHook: testHook && `${testHook}-lock`
                                                    }, void 0),
                                                    jsxs("span", Object.assign({
                                                        className: styles.title
                                                    }, {
                                                        children: [
                                                            jsx(Snippet, Object.assign({}, snippetProps, {
                                                                attribute: "name"
                                                            }), void 0),
                                                            jsx("span", Object.assign({
                                                                className: styles.tag
                                                            }, {
                                                                children: jsx(Tag, Object.assign({
                                                                    variant: "filled",
                                                                    fillColor: "colorFiftyShadesLighter"
                                                                }, {
                                                                    children: renderType(hit.type, hit.tier)
                                                                }), void 0)
                                                            }), void 0)
                                                        ]
                                                    }), void 0)
                                                ]
                                            }), void 0),
                                            jsx("div", Object.assign({
                                                className: styles.breadcrumbs
                                            }, {
                                                children: jsx(Snippet, Object.assign({}, snippetProps, {
                                                    attribute: `categories.${Object.keys(hit.categories).pop()}`
                                                }), void 0)
                                            }), void 0),
                                            jsx(Text, Object.assign({
                                                as: "p",
                                                variant: "bodySmall1X",
                                                color: "colorFiftyShadesDark"
                                            }, {
                                                children: jsx(Snippet, Object.assign({}, snippetProps, {
                                                    attribute: mainAttribute
                                                }), void 0)
                                            }), void 0)
                                        ]
                                    }, void 0))
                                }), hit.objectID);
                            })
                        }), void 0)
                    }), void 0),
                    jsx("div", Object.assign({
                        id: footerId,
                        className: styles.footer
                    }, {
                        children: jsx("span", {
                            children: footer
                        }, void 0)
                    }), void 0)
                ]
            }), void 0)
        ]
    }), void 0);
}
// @ts-ignore TODO-TS[ENHANCEMENT] improved types
const ConnectedAutocomplete = connectAutoComplete(Autocomplete);
function Search(props) {
    const { indexName , searchClient , isOpen: defaultIsOpen , searchParameters , onOpen , onClose , resetOnClose , testHook , trigger , ...autocompleteProps } = props;
    // we don't want to exclude these from `autocompleteProps`
    const { placeholder , resetAssistiveText  } = autocompleteProps;
    const [isOpen, setIsOpen] = useState(false);
    const [query, setQuery] = useState('');
    useEffect(()=>{
        setIsOpen(!!defaultIsOpen);
    }, [
        defaultIsOpen
    ]);
    const triggerOnClick = ()=>{
        setIsOpen(true);
        onOpen();
    };
    const triggerOnReset = ()=>{
        setQuery('');
    };
    const handleClose = (value)=>{
        if (value) setQuery(value);
        if (resetOnClose) triggerOnReset();
        setIsOpen(false);
        // when the dialog is dismissed we don't receive any value, so we have to use the state
        onClose(value || query);
    };
    return jsxs(Fragment, {
        children: [
            trigger ? /*#__PURE__*/ cloneElement(trigger, {
                onClick: triggerOnClick
            }) : jsx(Trigger, {
                placeholder: placeholder,
                value: query,
                onClick: triggerOnClick,
                onReset: triggerOnReset,
                resetAssistiveText: resetAssistiveText,
                testHook: testHook && `${testHook}-trigger`
            }, void 0),
            jsx(Dialog, Object.assign({
                isOpen: isOpen,
                onClose: handleClose,
                testHook: testHook && `${testHook}-dialog`
            }, {
                children: jsxs(InstantSearch, Object.assign({
                    indexName: indexName,
                    searchClient: searchClient
                }, {
                    children: [
                        jsx(Configure, Object.assign({
                            analytics: false,
                            attributesToRetrieve: [
                                'type',
                                'access_level',
                                'name',
                                'categories',
                                'description',
                                'captions',
                                '*', 
                            ],
                            attributesToSnippet: "*:30",
                            responseFields: [
                                'hits'
                            ]
                        }, searchParameters), void 0),
                        jsx(ConnectedAutocomplete, Object.assign({}, autocompleteProps, {
                            // we want the query in Autocomplete to be in sync with the value
                            // stored here so when we close the dialog the trigger can show the
                            // correct value
                            // @ts-ignore TODO-TS going to revisit
                            query: query,
                            setQuery: setQuery,
                            onClose: handleClose,
                            testHook: testHook && `${testHook}-autocomplete`
                        }), void 0)
                    ]
                }), void 0)
            }), void 0)
        ]
    }, void 0);
}

export { Search as default };
