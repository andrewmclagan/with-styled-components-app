import 'core-js/modules/web.dom-collections.iterator.js';
import { useState, useEffect } from 'react';
import { useInView } from 'react-intersection-observer';

function useSyncScrolling(rootRef, targetSelector) {
    // There are a few things going on here:
    // - the `counter` variable is incremented whenever the keydown event is triggered on the root
    // - the first `useEffect` updates the currently highlighted result (the target) and sets the
    //   target to be observed by `useInView`
    //    - this is run as an effect because we don't know when the hightlighted result changes but we
    //      can approximate it will happen on keydown
    //    - `useInView` is triggered once because we don't want to track the target's visibility as
    //      the user interacts with the root -- the user might use keyboard navigation as well as
    //      scroll with the mouse
    // - the second `useEffect` checks if the target is in view and scrolls the root the appropriate
    //   amount so the target gets into view
    //   - this only needs to be done once per highlighted item; if the user starts scrolling with the
    //     mouse we don't want to override the scroll position when the highlighted item becomes
    //     obstructed again
    const [counter, setCounter] = useState(0);
    const [target, setTarget] = useState(null);
    const [observe, inView, entry] = useInView({
        root: rootRef.current,
        threshold: 0.95,
        triggerOnce: true
    });
    useEffect(()=>{
        // the element might not be in the DOM
        if (!rootRef.current) return;
        const highlighted = rootRef.current.querySelector(targetSelector);
        observe(highlighted);
        setTarget(highlighted);
    }, [
        counter,
        observe,
        rootRef,
        targetSelector
    ]);
    useEffect(()=>{
        if (rootRef.current && entry && target && !inView && entry.rootBounds) {
            const { rootBounds , boundingClientRect  } = entry;
            const delta = boundingClientRect.bottom > rootBounds.bottom ? boundingClientRect.bottom - rootBounds.bottom : boundingClientRect.top - rootBounds.top;
            rootRef.current.scrollBy(0, delta);
        }
    }, [
        entry,
        inView,
        rootRef,
        target
    ]);
    const onKeyDown = ()=>setCounter((count)=>count + 1
        )
    ;
    return {
        onKeyDown
    };
}

export { useSyncScrolling as default };
