{"version":3,"file":"index.es.js","sources":["../src/math-block/inner-editor.ts","../src/math-block/style.ts","../src/math-block/index.ts","../src/math-inline/index.ts","../src/nodes.ts","../src/index.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\n\nimport { EditorState, EditorView, keymap, newlineInCode, Node, StepMap, TextSelection } from '@milkdown/prose';\n\nexport const createInnerEditor = (outerView: EditorView, getPos: () => number) => {\n    let isEditing = false;\n    let innerView: EditorView | undefined;\n\n    const openEditor = ($: HTMLElement, doc: Node) => {\n        innerView = new EditorView($, {\n            state: EditorState.create({\n                doc,\n                plugins: [\n                    keymap({\n                        Tab: (state, dispatch) => {\n                            if (dispatch) {\n                                dispatch(state.tr.insertText('\\t'));\n                            }\n                            return true;\n                        },\n                        Enter: newlineInCode,\n                        'Mod-Enter': (_, dispatch) => {\n                            if (dispatch) {\n                                const { state } = outerView;\n                                const { to } = state.selection;\n                                const tr = state.tr.replaceWith(to, to, state.schema.nodes.paragraph.createAndFill());\n                                outerView.dispatch(tr.setSelection(TextSelection.create(tr.doc, to)));\n                                outerView.focus();\n                            }\n\n                            return true;\n                        },\n                    }),\n                ],\n            }),\n            dispatchTransaction: (tr) => {\n                if (!innerView) return;\n                const { state, transactions } = innerView.state.applyTransaction(tr);\n                innerView.updateState(state);\n\n                if (!tr.getMeta('fromOutside')) {\n                    const outerTr = outerView.state.tr;\n                    const offsetMap = StepMap.offset(getPos() + 1);\n\n                    transactions.forEach((transaction) => {\n                        const { steps } = transaction;\n                        steps.forEach((step) => {\n                            const mapped = step.map(offsetMap);\n\n                            if (!mapped) {\n                                throw Error('step discarded!');\n                            }\n                            outerTr.step(mapped);\n                        });\n                    });\n                    if (outerTr.docChanged) outerView.dispatch(outerTr);\n                }\n            },\n        });\n        innerView.focus();\n        const { state } = innerView;\n        innerView.dispatch(state.tr.setSelection(TextSelection.create(state.doc, 0)));\n        isEditing = true;\n    };\n\n    const closeEditor = () => {\n        if (innerView) {\n            innerView.destroy();\n        }\n        innerView = undefined;\n        isEditing = false;\n    };\n\n    return {\n        isEditing: () => isEditing,\n        innerView: () => innerView,\n        openEditor,\n        closeEditor,\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Utils } from '@milkdown/utils';\n\nexport const getStyle = (utils: Utils) => {\n    const codeStyle = utils.getStyle(\n        ({ palette, size, font }, { css }) => css`\n            color: ${palette('neutral', 0.87)};\n            background-color: ${palette('background')};\n            border-radius: ${size.radius};\n            padding: 1rem 2rem;\n            font-size: 0.875rem;\n            font-family: ${font.code};\n            overflow: hidden;\n            .ProseMirror {\n                outline: none;\n            }\n        `,\n    );\n    const hideCodeStyle = utils.getStyle(\n        (_, { css }) => css`\n            display: none;\n        `,\n    );\n    const previewPanelStyle = utils.getStyle(\n        (_, { css }) => css`\n            display: flex;\n            justify-content: center;\n            padding: 1rem 0;\n        `,\n    );\n\n    return {\n        codeStyle,\n        hideCodeStyle,\n        previewPanelStyle,\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { textblockTypeInputRule } from '@milkdown/prose';\nimport { createNode } from '@milkdown/utils';\nimport katex from 'katex';\n\nimport { createInnerEditor } from './inner-editor';\nimport { getStyle } from './style';\n\nconst inputRegex = /^\\$\\$\\s$/;\n\ntype Options = {\n    placeholder: {\n        empty: string;\n        error: string;\n    };\n};\n\nexport const mathBlock = createNode<string, Options>((utils, options) => {\n    const { codeStyle, hideCodeStyle, previewPanelStyle } = getStyle(utils);\n    const id = 'math_block';\n    const placeholder = {\n        empty: 'Empty',\n        error: 'Syntax Error',\n        ...(options?.placeholder ?? {}),\n    };\n\n    return {\n        id,\n        schema: () => ({\n            content: 'text*',\n            group: 'block',\n            marks: '',\n            defining: true,\n            atom: true,\n            code: true,\n            isolating: true,\n            attrs: {\n                value: {\n                    default: '',\n                },\n            },\n            parseDOM: [\n                {\n                    tag: `div[data-type=\"${id}\"]`,\n                    preserveWhitespace: 'full',\n                    getAttrs: (dom) => {\n                        if (!(dom instanceof HTMLElement)) {\n                            throw new Error();\n                        }\n                        return {\n                            value: dom.dataset['value'],\n                        };\n                    },\n                },\n            ],\n            toDOM: (node) => {\n                return [\n                    'div',\n                    {\n                        class: utils.getClassName(node.attrs, 'mermaid'),\n                        'data-type': id,\n                        'data-value': node.attrs['value'],\n                    },\n                    0,\n                ];\n            },\n            parseMarkdown: {\n                match: ({ type }) => type === 'math',\n                runner: (state, node, type) => {\n                    const value = node['value'] as string;\n                    state.openNode(type, { value });\n                    if (value) {\n                        state.addText(value);\n                    }\n                    state.closeNode();\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === id,\n                runner: (state, node) => {\n                    let text = '';\n                    node.forEach((n) => {\n                        text += n.text as string;\n                    });\n                    state.addNode('math', undefined, text);\n                },\n            },\n        }),\n        view: () => (node, view, getPos) => {\n            const innerEditor = createInnerEditor(view, getPos);\n\n            let currentNode = node;\n            const dom = document.createElement('div');\n            dom.classList.add('math-block');\n            const code = document.createElement('div');\n            code.dataset['type'] = id;\n            code.dataset['value'] = node.attrs['value'];\n            if (codeStyle && hideCodeStyle) {\n                code.classList.add(codeStyle, hideCodeStyle);\n            }\n\n            const rendered = document.createElement('div');\n            if (previewPanelStyle) {\n                rendered.classList.add(previewPanelStyle);\n            }\n\n            dom.append(code);\n\n            const render = (code: string) => {\n                try {\n                    if (!code) {\n                        rendered.innerHTML = placeholder.empty;\n                    } else {\n                        katex.render(code, rendered);\n                    }\n                } catch {\n                    rendered.innerHTML = placeholder.error;\n                } finally {\n                    dom.appendChild(rendered);\n                }\n            };\n\n            render(node.attrs['value']);\n\n            return {\n                dom,\n                update: (updatedNode) => {\n                    if (!updatedNode.sameMarkup(currentNode)) return false;\n                    currentNode = updatedNode;\n\n                    const innerView = innerEditor.innerView();\n                    if (innerView) {\n                        const state = innerView.state;\n                        const start = updatedNode.content.findDiffStart(state.doc.content);\n                        if (start !== null && start !== undefined) {\n                            const diff = updatedNode.content.findDiffEnd(state.doc.content);\n                            if (diff) {\n                                let { a: endA, b: endB } = diff;\n                                const overlap = start - Math.min(endA, endB);\n                                if (overlap > 0) {\n                                    endA += overlap;\n                                    endB += overlap;\n                                }\n                                innerView.dispatch(\n                                    state.tr.replace(start, endB, node.slice(start, endA)).setMeta('fromOutside', true),\n                                );\n                            }\n                        }\n                    }\n\n                    const newVal = updatedNode.content.firstChild?.text || '';\n                    code.dataset['value'] = newVal;\n\n                    render(newVal);\n\n                    return true;\n                },\n                selectNode: () => {\n                    if (!view.editable) return;\n                    if (hideCodeStyle) {\n                        code.classList.remove(hideCodeStyle);\n                    }\n                    innerEditor.openEditor(code, currentNode);\n                    dom.classList.add('ProseMirror-selectednode');\n                },\n                deselectNode: () => {\n                    if (hideCodeStyle) {\n                        code.classList.add(hideCodeStyle);\n                    }\n                    innerEditor.closeEditor();\n                    dom.classList.remove('ProseMirror-selectednode');\n                },\n                stopEvent: (event) => {\n                    const innerView = innerEditor.innerView();\n                    const { target } = event;\n                    const isChild = target && innerView?.dom.contains(target as Element);\n                    return !!(innerView && isChild);\n                },\n                ignoreMutation: () => true,\n                destroy() {\n                    rendered.remove();\n                    code.remove();\n                    dom.remove();\n                },\n            };\n        },\n        inputRules: (nodeType) => [textblockTypeInputRule(inputRegex, nodeType)],\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { findSelectedNodeOfType, InputRule, NodeSelection } from '@milkdown/prose';\nimport { createNode } from '@milkdown/utils';\nimport katex from 'katex';\n\ntype Options = {\n    placeholder: {\n        empty: string;\n        error: string;\n    };\n};\n\nexport const ModifyInlineMath = createCmdKey<string>('ModifyInlineMath');\nexport const mathInline = createNode<string, Options>((utils, options) => {\n    const placeholder = {\n        empty: '(empty)',\n        error: '(error)',\n        ...(options?.placeholder ?? {}),\n    };\n    const style = utils.getStyle(({ size, palette }, { css }) => {\n        return css`\n            font-size: unset;\n\n            &.ProseMirror-selectednode {\n                outline: none;\n                border: ${size.lineWidth} solid ${palette('line')};\n            }\n        `;\n    });\n\n    const id = 'math_inline';\n    return {\n        id,\n        schema: () => ({\n            group: 'inline',\n            inline: true,\n            atom: true,\n            attrs: {\n                value: {\n                    default: '',\n                },\n            },\n            parseDOM: [\n                {\n                    tag: `span[data-type=\"${id}\"]`,\n                    getAttrs: (dom) => {\n                        if (!(dom instanceof HTMLElement)) {\n                            throw new Error();\n                        }\n                        return {\n                            value: dom.dataset['value'],\n                        };\n                    },\n                },\n            ],\n            toDOM: (node) => ['span', { class: style, 'data-type': id, 'data-value': node.attrs['value'] }],\n            parseMarkdown: {\n                match: (node) => node.type === 'inlineMath',\n                runner: (state, node, type) => {\n                    const code = node['value'] as string;\n                    state.addNode(type, { value: code });\n                },\n            },\n            toMarkdown: {\n                match: (node) => node.type.name === id,\n                runner: (state, node) => {\n                    state.addNode('inlineMath', undefined, node.attrs['value']);\n                },\n            },\n        }),\n        commands: (nodeType) => [\n            createCmd(ModifyInlineMath, (value = '') => (state, dispatch) => {\n                const node = findSelectedNodeOfType(state.selection, nodeType);\n                if (!node) return false;\n\n                const { tr } = state;\n                const _tr = tr.setNodeMarkup(node.pos, undefined, { ...node.node.attrs, value });\n                dispatch?.(_tr.setSelection(NodeSelection.create(_tr.doc, node.pos)));\n\n                return true;\n            }),\n        ],\n        view: () => (node) => {\n            let currentNode = node;\n            const dom = document.createElement('span');\n            if (style) {\n                dom.classList.add(style);\n            }\n            const render = (code: string) => {\n                try {\n                    if (!code) {\n                        dom.innerHTML = placeholder.empty;\n                    } else {\n                        katex.render(code, dom);\n                    }\n                } catch {\n                    dom.innerHTML = placeholder.error;\n                }\n            };\n            render(node.attrs['value']);\n            return {\n                dom,\n                update: (updatedNode) => {\n                    if (!updatedNode.sameMarkup(currentNode)) return false;\n                    currentNode = updatedNode;\n\n                    const newVal = updatedNode.attrs['value'];\n\n                    render(newVal);\n\n                    return true;\n                },\n            };\n        },\n        inputRules: (nodeType) => [\n            new InputRule(/(?:\\$)([^$]+)(?:\\$)$/, (state, match, start, end) => {\n                const $start = state.doc.resolve(start);\n                const index = $start.index();\n                const $end = state.doc.resolve(end);\n                if (!$start.parent.canReplaceWith(index, $end.index(), nodeType)) {\n                    return null;\n                }\n                const value = match[1];\n                return state.tr.replaceRangeWith(\n                    start,\n                    end,\n                    nodeType.create(\n                        {\n                            value,\n                        },\n                        nodeType.schema.text(value),\n                    ),\n                );\n            }),\n        ],\n    };\n});\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { AtomList } from '@milkdown/utils';\n\nimport { mathBlock } from './math-block';\nimport { mathInline } from './math-inline';\n\nexport const nodes = AtomList.create([mathInline(), mathBlock()]);\nexport * from './math-block';\nexport * from './math-inline';\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { AtomList, createPlugin } from '@milkdown/utils';\nimport remarkMath from 'remark-math';\n\nimport { nodes } from './nodes';\n\nconst remarkPlugin = createPlugin(() => {\n    return {\n        remarkPlugins: () => [remarkMath],\n    };\n});\n\nexport const math = AtomList.create([remarkPlugin(), ...nodes]);\nexport * from './nodes';\n"],"names":[],"mappings":"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"}