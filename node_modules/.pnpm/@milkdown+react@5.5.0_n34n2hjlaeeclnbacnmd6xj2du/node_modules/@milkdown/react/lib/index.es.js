import { editorViewCtx, rootCtx } from "@milkdown/core";
import React, { forwardRef, useImperativeHandle } from "react";
import { Node, Mark } from "@milkdown/prose";
import { customAlphabet } from "nanoid";
import { createPortal } from "react-dom";
const portalContext = React.createContext(() => () => {
  throw new Error();
});
const getId = (portals) => portals.map((x) => x.key).join(",");
const Portals = React.memo(({ portals }) => {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, portals);
}, (prev, next) => {
  return getId(prev.portals) === getId(next.portals);
});
const nodeContext = React.createContext({
  ctx: void 0,
  node: void 0,
  view: void 0,
  getPos: void 0,
  decorations: void 0
});
const ReactNodeContainer = ({ ctx, node, view, getPos, decorations, children }) => {
  return /* @__PURE__ */ React.createElement(nodeContext.Provider, {
    value: { ctx, node, view, getPos, decorations }
  }, children);
};
const useNodeCtx = () => React.useContext(nodeContext);
const Content = ({ dom, isInline }) => {
  const containerRef = React.useRef(null);
  React.useEffect(() => {
    const { current } = containerRef;
    if (!current || !dom)
      return;
    current.appendChild(dom);
  }, [dom]);
  if (isInline) {
    return /* @__PURE__ */ React.createElement("span", {
      className: "content-dom-wrapper",
      ref: containerRef
    });
  }
  return /* @__PURE__ */ React.createElement("div", {
    className: "content-dom-wrapper",
    ref: containerRef
  });
};
const nanoid = customAlphabet("abcedfghicklmn", 10);
const createReactView = (addPortal, removePortalByKey) => (component) => (ctx) => (node, view, getPos, decorations) => new ReactNodeView(ctx, component, addPortal, removePortalByKey, node, view, getPos, decorations);
class ReactNodeView {
  constructor(ctx, component, addPortal, removePortalByKey, node, view, getPos, decorations) {
    this.ctx = ctx;
    this.component = component;
    this.addPortal = addPortal;
    this.removePortalByKey = removePortalByKey;
    this.node = node;
    this.view = view;
    this.getPos = getPos;
    this.decorations = decorations;
    const dom = document.createElement(this.isInlineOrMark ? "span" : "div");
    dom.classList.add("dom-wrapper");
    const contentDOM = node instanceof Node && node.isLeaf ? void 0 : document.createElement(this.isInlineOrMark ? "span" : "div");
    if (contentDOM) {
      contentDOM.classList.add("content-dom");
      dom.appendChild(contentDOM);
    }
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.key = nanoid();
    this.renderPortal();
  }
  get isInlineOrMark() {
    return this.node instanceof Mark || this.node.isInline;
  }
  renderPortal() {
    if (!this.dom)
      return;
    const Component = this.component;
    const portal = createPortal(/* @__PURE__ */ React.createElement(ReactNodeContainer, {
      ctx: this.ctx,
      node: this.node,
      view: this.view,
      getPos: this.getPos,
      decorations: this.decorations
    }, /* @__PURE__ */ React.createElement(Component, null, /* @__PURE__ */ React.createElement(Content, {
      isInline: this.isInlineOrMark,
      dom: this.contentDOM
    }))), this.dom, this.key);
    this.addPortal(portal);
  }
  destroy() {
    this.dom = void 0;
    this.contentDOM = void 0;
    this.removePortalByKey(this.key);
  }
  ignoreMutation(mutation) {
    if (!this.contentDOM) {
      return true;
    }
    return !this.contentDOM.contains(mutation.target);
  }
}
const useGetEditor = (getEditor) => {
  const renderReact = React.useContext(portalContext);
  const divRef = React.useRef(null);
  const editorRef = React.useRef();
  React.useEffect(() => {
    const div = divRef.current;
    if (!div)
      return;
    const editor = getEditor(div, renderReact);
    if (!editor)
      return;
    editor.create().then((editor2) => {
      editorRef.current = editor2;
      return;
    }).catch(console.error);
    return () => {
      var _a, _b, _c;
      const view = (_a = editorRef.current) == null ? void 0 : _a.action((ctx) => ctx.get(editorViewCtx));
      const root = (_b = editorRef.current) == null ? void 0 : _b.action((ctx) => ctx.get(rootCtx));
      (_c = root == null ? void 0 : root.firstChild) == null ? void 0 : _c.remove();
      view == null ? void 0 : view.destroy();
    };
  }, [getEditor, renderReact]);
  return { divRef, editorRef };
};
const EditorComponent = forwardRef(({ editor }, ref) => {
  const refs = useGetEditor(editor);
  useImperativeHandle(ref, () => ({
    get: () => {
      return refs.editorRef.current;
    },
    dom: () => {
      return refs.divRef.current;
    }
  }));
  return /* @__PURE__ */ React.createElement("div", {
    ref: refs.divRef
  });
});
const ReactEditor = forwardRef(({ editor }, ref) => {
  const [portals, setPortals] = React.useState([]);
  const addPortal = React.useCallback((portal) => {
    setPortals((ps) => [...ps, portal]);
  }, []);
  const removePortalByKey = React.useCallback((key) => {
    setPortals((x) => {
      const index = x.findIndex((p) => p.key === key);
      return [...x.slice(0, index), ...x.slice(index + 1)];
    });
  }, []);
  const renderReact = React.useCallback((Component) => createReactView(addPortal, removePortalByKey)(Component), [addPortal, removePortalByKey]);
  return /* @__PURE__ */ React.createElement(portalContext.Provider, {
    value: renderReact
  }, /* @__PURE__ */ React.createElement(Portals, {
    portals
  }), /* @__PURE__ */ React.createElement(EditorComponent, {
    ref,
    editor
  }));
});
const useEditor = (getEditor, deps = []) => {
  return React.useCallback((...args) => getEditor(...args), deps);
};
export { Content, EditorComponent, ReactEditor, ReactNodeContainer, ReactNodeView, createReactView, useEditor, useNodeCtx };
//# sourceMappingURL=index.es.js.map
